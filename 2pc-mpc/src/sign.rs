// Author: dWallet Labs, Ltd.
// SPDX-License-Identifier: CC-BY-NC-ND-4.0

#![allow(clippy::too_many_arguments)]

use std::collections::{HashMap, HashSet};
use std::fmt::Debug;
use std::ops::Neg;

use crypto_bigint::{ConcatMixed, NonZero, Uint};
use merlin::Transcript;
use serde::{Deserialize, Serialize};

use commitment::{CommitmentSizedNumber, Pedersen};
use group::{
    AffineXCoordinate, CsRng, GroupElement as _, Invert, PartyID, PrimeGroupElement,
    StatisticalSecuritySizedNumber,
};
use homomorphic_encryption::{AdditivelyHomomorphicEncryptionKey, GroupsPublicParametersAccessors};
use mpc::{two_party, AsynchronouslyAdvanceable};
use proof::TranscriptProtocol;

use crate::languages::{KnowledgeOfDecommitmentProof, KnowledgeOfDecommitmentUCProof};
use crate::{dkg, presign, presign::Presign, Error};

pub mod centralized_party;
#[cfg(feature = "class_groups")]
pub mod class_groups;
pub mod decentralized_party;

#[cfg(feature = "paillier")]
pub mod paillier;

/// An instantiation of the 2PC-MPC Sign protocol.
pub trait Protocol: dkg::Protocol + presign::Protocol {
    /// The hashed message to sign.
    type HashedMessage: Serialize + for<'a> Deserialize<'a> + Clone + Debug + PartialEq + Eq;

    /// The output of the Sign protocol.
    type Signature: Serialize
        + for<'a> Deserialize<'a>
        + Clone
        + Debug
        + PartialEq
        + Eq
        + Send
        + Sync;

    /// A decryption key share.
    type DecryptionKeyShare: Sync + Send;

    /// The decryption key share public parameters.
    type DecryptionKeySharePublicParameters: Serialize + Clone + Debug + PartialEq + Eq;

    /// The public input of the decentralized party's Sign protocol.
    type SignDecentralizedPartyPublicInput: From<(
            HashSet<PartyID>,
            Self::ProtocolPublicParameters,
            Self::HashedMessage,
            Self::DecentralizedPartyDKGOutput,
            Self::Presign,
            Self::SignMessage,
            Self::DecryptionKeySharePublicParameters,
        )> + Serialize
        + Clone
        + Debug
        + PartialEq
        + Eq
        + Sync
        + Send;

    /// A party participating in the decentralized party's Sign protocol.
    type SignDecentralizedParty: mpc::Party<
            PublicInput = Self::SignDecentralizedPartyPublicInput,
            PublicOutputValue = Self::Signature,
            PublicOutput = Self::Signature,
        > + AsynchronouslyAdvanceable<PrivateInput = HashMap<PartyID, Self::DecryptionKeyShare>>
        + Sync
        + Send;

    /// The public input of the centralized party in the Sign protocol.
    type SignCentralizedPartyPublicInput: From<(
            Self::HashedMessage,
            Self::CentralizedPartyDKGPublicOutput,
            Self::Presign,
            Self::ProtocolPublicParameters,
        )> + Serialize
        + Clone
        + Debug
        + PartialEq
        + Eq;

    /// The outgoing message of the centralized party in the Sign protocol.
    type SignMessage: Serialize + for<'a> Deserialize<'a> + Clone + Debug + PartialEq + Eq;

    /// The party of the centralized party in the Sign protocol.
    type SignCentralizedParty: two_party::Round<
        IncomingMessage = (),
        OutgoingMessage = Self::SignMessage,
        PrivateInput = Self::CentralizedPartySecretKeyShare,
        PrivateOutput = (),
        PublicOutput = (),
        PublicOutputValue = (),
        PublicInput = Self::SignCentralizedPartyPublicInput,
    >;

    /// This function implements step (2e) of the Sign protocol:
    /// Verifies zk-proofs of C_{k}, C_{\alpha}, C_{\beta}, C_{kx}, R, R_{B} ,\textsf{ct}_{\alpha,\beta}. and \textsf{ct}_A.
    /// src: <https://eprint.iacr.org/archive/2024/253/20240217:153208>
    /// Verify the validity of the encrypted signature parts sent by the centralized party.
    /// If this function returns `Ok()`, it means that a valid signature over `message` is
    /// guaranteed to be able to be generated by the decentralized party, whenever a threshold of
    /// honest parties decides to engage in the signing protocol.
    ///
    /// Note: `hashed_message` is a `Scalar` which must be a hash on the message bytes translated into a
    /// 32-byte number.
    fn verify_encryption_of_signature_parts_prehash(
        protocol_public_parameters: &Self::ProtocolPublicParameters,
        dkg_output: Self::DecentralizedPartyDKGOutput,
        presign: Self::Presign,
        sign_message: Self::SignMessage,
        hashed_message: Self::HashedMessage,
        rng: &mut impl CsRng,
    ) -> crate::Result<()>;
}

pub fn verify_signature<
    const SCALAR_LIMBS: usize,
    GroupElement: PrimeGroupElement<SCALAR_LIMBS> + AffineXCoordinate<SCALAR_LIMBS>,
>(
    r: GroupElement::Scalar,
    s: GroupElement::Scalar,
    m: GroupElement::Scalar,
    public_key: GroupElement,
) -> crate::Result<()> {
    // Attend to malleability by not accepting non-normalized signatures.
    if s.neg().value() < s.value() {
        return Err(Error::SignatureVerification);
    };

    let generator = public_key.generator();
    let inverted_s: GroupElement::Scalar =
        Option::from(s.invert()).ok_or(Error::SignatureVerification)?;
    if (((m * inverted_s) * generator) + ((r * inverted_s) * public_key)).x() != r {
        return Err(Error::SignatureVerification);
    }

    Ok(())
}

/// This function derives the combined signature public nonce share of the decentralized party
/// $R'_B$ and the encryption of its masked signature nonce share $\textsf{ct}_{\gamma\cdot k}$ (i.e. masked discrete
/// log ) from two points $R_{B,0}, R_{B,1}$ and encryptions of
/// their masked discrete logs $\textsf{ct}_{\gamma\cdot k_{0}}, \textsf{ct}_{\gamma\cdot k_{1}}$ by applying a linear combination using the
/// public randomizers $\mu_{x}^{0},\mu_{x}^{1},\mu_{x}^{G}$ derived from a hash
/// $\mathcal{H}(\textsf{sid},\textsf{msg},\mathbb{G},G,q,H,X,\textsf{pres}_{X,\textsf{sid}},C_{k},C_{kx},X_{B},
/// C_{\alpha},C_{\beta},\pi_{k},\pi_{\alpha},\pi_{\beta})$
///  - $\textsf{ct}_{\gamma\cdot k}=(mu_{k}^{0}\odot \textsf{ct}_{\gamma\cdot k_{0}})\oplus(\mu_{k}^{1}\odot\textsf{ct}_{\gamma\cdot k_{1}}\oplus \mu_{k}^{G}\odot \textsf{ct}_{\gamma})$
///  - $\mu_{k}^{0}\cdotR_{B,0})+\mu_{k}^{1}\cdot R_{B,1}+\mu_{k}^{G}\cdot G$
///
/// NOTE: The protocol uses $ /textsf{msg} $ as input to the random oracle but using any strong collision resistant hash instead is safe.
///       Therefore, although this deviates slightly from the protocol, we can safely use here `hashed_message` instead of the message bytes.
#[allow(clippy::too_many_arguments)]
#[allow(dead_code)]
fn derive_randomized_decentralized_party_public_nonce_share_and_encryption_of_nonce_share<
    const SCALAR_LIMBS: usize,
    const PLAINTEXT_SPACE_SCALAR_LIMBS: usize,
    GroupElement: PrimeGroupElement<SCALAR_LIMBS>,
    EncryptionKey: AdditivelyHomomorphicEncryptionKey<PLAINTEXT_SPACE_SCALAR_LIMBS>,
>(
    session_id: CommitmentSizedNumber,
    hashed_message: &GroupElement::Scalar,
    presign: Presign<GroupElement::Value, group::Value<EncryptionKey::CiphertextSpaceGroupElement>>,
    encryption_scheme_public_parameters: &EncryptionKey::PublicParameters,
    group_public_parameters: &GroupElement::PublicParameters,
    commitment_scheme_public_parameters: &commitment::PublicParameters<
        SCALAR_LIMBS,
        Pedersen<1, SCALAR_LIMBS, GroupElement::Scalar, GroupElement>,
    >,
    public_key: &GroupElement::Value,
    centralized_party_public_key_share: &GroupElement::Value,
    signature_nonce_share_commitment: &GroupElement,
    alpha_displacer_commitment: &GroupElement,
    beta_displacer_commitment: &GroupElement,
    signature_nonce_share_by_secret_share_commitment: &GroupElement,
    non_zero_commitment_to_signature_nonce_share_proof: &KnowledgeOfDecommitmentProof<
        SCALAR_LIMBS,
        GroupElement,
    >,
    non_zero_commitment_to_alpha_displacer_share_proof: &KnowledgeOfDecommitmentProof<
        SCALAR_LIMBS,
        GroupElement,
    >,
    commitment_to_beta_displacer_share_uc_proof: &KnowledgeOfDecommitmentUCProof<
        SCALAR_LIMBS,
        GroupElement,
    >,
) -> crate::Result<(EncryptionKey::CiphertextSpaceGroupElement, GroupElement)>
where
    Uint<SCALAR_LIMBS>: ConcatMixed<StatisticalSecuritySizedNumber>
        + for<'a> From<
            &'a <Uint<SCALAR_LIMBS> as ConcatMixed<StatisticalSecuritySizedNumber>>::MixedOutput,
        >,
{
    let generator = GroupElement::generator_from_public_parameters(group_public_parameters)?;

    // $\textsf{ct}_{\gamma\cdot k_{0}$
    let encryption_of_masked_decentralized_party_nonce_share_first_part =
        EncryptionKey::CiphertextSpaceGroupElement::new(
            presign.encryption_of_masked_decentralized_party_nonce_share_first_part,
            encryption_scheme_public_parameters.ciphertext_space_public_parameters(),
        )?;

    // $R_{B,0}$
    let decentralized_party_nonce_public_share_first_part = GroupElement::new(
        presign.decentralized_party_nonce_public_share_first_part,
        group_public_parameters,
    )?;

    // $\textsf{ct}_{\gamma\cdot k_{1}}$
    let encryption_of_masked_decentralized_party_nonce_share_second_part =
        EncryptionKey::CiphertextSpaceGroupElement::new(
            presign.encryption_of_masked_decentralized_party_nonce_share_second_part,
            encryption_scheme_public_parameters.ciphertext_space_public_parameters(),
        )?;

    // $R_{B,1}$
    let decentralized_party_nonce_public_share_second_part = GroupElement::new(
        presign.decentralized_party_nonce_public_share_second_part,
        group_public_parameters,
    )?;

    // $ \textst{ct}_\gamma $
    let encryption_of_mask = EncryptionKey::CiphertextSpaceGroupElement::new(
        presign.encryption_of_mask,
        encryption_scheme_public_parameters.ciphertext_space_public_parameters(),
    )?;

    let mut transcript = Transcript::new(
        b"DKG randomize decentralized party public key share and encryption of secret key share",
    );

    transcript.append_uint(b"$ sid $", &session_id);
    transcript.serialize_to_transcript_as_json(b"$ msg $", &hashed_message.value())?;
    transcript.transcribe(b"$ \\GG,G,q $", group_public_parameters.clone())?;
    transcript.transcribe(b"$ G, H $", commitment_scheme_public_parameters.clone())?;
    transcript.serialize_to_transcript_as_json(b"$X$", &public_key)?;
    transcript.serialize_to_transcript_as_json(
        b"$X_{\\CentralizedParty}$ $",
        &centralized_party_public_key_share,
    )?;
    transcript.serialize_to_transcript_as_json(b"$\\pres_{X,\\sid}", &presign)?;
    transcript
        .serialize_to_transcript_as_json(b"$C_{k}$", &signature_nonce_share_commitment.value())?;
    transcript
        .serialize_to_transcript_as_json(b"$C_{\\alpha}$", &alpha_displacer_commitment.value())?;
    transcript
        .serialize_to_transcript_as_json(b"$C_{\\beta}$", &beta_displacer_commitment.value())?;
    transcript.serialize_to_transcript_as_json(
        b"$C_{kx}$",
        &signature_nonce_share_by_secret_share_commitment.value(),
    )?;
    transcript.serialize_to_transcript_as_json(
        b"$\\pi_k$",
        non_zero_commitment_to_signature_nonce_share_proof,
    )?;
    transcript.serialize_to_transcript_as_json(
        b"$\\pi_{\\alpha}$",
        non_zero_commitment_to_alpha_displacer_share_proof,
    )?;
    transcript.serialize_to_transcript_as_json(
        b"$\\pi_{\\beta}$",
        commitment_to_beta_displacer_share_uc_proof,
    )?;

    let group_order = NonZero::new(GroupElement::order_from_public_parameters(
        group_public_parameters,
    ))
    .unwrap();

    let first_decentralized_party_nonce_share_public_randomizer: Uint<SCALAR_LIMBS> =
        group::Value::<GroupElement::Scalar>::from(
            transcript.uniformly_reduced_challenge::<SCALAR_LIMBS>(b"$\\mu_{k}^{0}$", &group_order),
        )
        .into();

    let second_decentralized_party_nonce_share_public_randomizer: Uint<SCALAR_LIMBS> =
        group::Value::<GroupElement::Scalar>::from(
            transcript.uniformly_reduced_challenge::<SCALAR_LIMBS>(b"$\\mu_{k}^{1}$", &group_order),
        )
        .into();

    let free_coefficient_decentralized_party_nonce_share_public_randomizer: Uint<SCALAR_LIMBS> =
        group::Value::<GroupElement::Scalar>::from(
            transcript.uniformly_reduced_challenge::<SCALAR_LIMBS>(b"$\\mu_{k}^{G}$", &group_order),
        )
        .into();

    // Compute $\textsf{ct}_{\gamma\cdot k}=(mu_{k}^{0}\odot \textsf{ct}_{\gamma\cdot k_{0}})\oplus(\mu_{k}^{1}\odot\textsf{ct}_{\gamma\cdot k_{1}}\oplus \mu_{k}^{G}\odot \textsf{ct}_{\gamma})$
    let encryption_of_masked_decentralized_party_nonce_share_before_displacing =
        ((encryption_of_masked_decentralized_party_nonce_share_first_part
            .scale_vartime(&first_decentralized_party_nonce_share_public_randomizer))
        .add_vartime(
            &(encryption_of_masked_decentralized_party_nonce_share_second_part
                .scale_vartime(&second_decentralized_party_nonce_share_public_randomizer)),
        ))
        .add_vartime(
            &(encryption_of_mask.scale_vartime(
                &free_coefficient_decentralized_party_nonce_share_public_randomizer,
            )),
        );

    // Compute $\mu_{k}^{0}\cdotR_{B,0})+\mu_{k}^{1}\cdot R_{B,1}+\mu_{k}^{G}\cdot G$
    let decentralized_party_nonce_public_share_before_displacing =
        ((decentralized_party_nonce_public_share_first_part
            .scale_vartime(&first_decentralized_party_nonce_share_public_randomizer))
        .add_vartime(
            &(decentralized_party_nonce_public_share_second_part
                .scale_vartime(&second_decentralized_party_nonce_share_public_randomizer)),
        ))
        .add_vartime(
            &(generator.scale_vartime(
                &free_coefficient_decentralized_party_nonce_share_public_randomizer,
            )),
        );

    Ok((
        encryption_of_masked_decentralized_party_nonce_share_before_displacing,
        decentralized_party_nonce_public_share_before_displacing,
    ))
}

#[cfg(all(
    any(test, feature = "benchmarking"),
    feature = "secp256k1",
    feature = "paillier",
    feature = "bulletproofs",
))]
#[allow(unused_imports)]
#[allow(dead_code)]
pub(crate) mod tests {
    use std::{collections::HashMap, ops::Neg, time::Duration};

    use criterion::measurement::{Measurement, WallTime};
    use crypto_bigint::subtle::Choice;
    use crypto_bigint::{ConstChoice, Int, Random, U256, U4096};
    use ecdsa::{
        elliptic_curve::{ops::Reduce, Scalar},
        hazmat::{bits2field, DigestAlgorithm},
        signature::{digest::Digest, Verifier},
        Signature, VerifyingKey,
    };
    use k256::sha2::digest::FixedOutput;
    use rand::prelude::IteratorRandom;
    use rstest::rstest;

    use ::class_groups::{
        Secp256k1DecryptionKey, Secp256k1DecryptionKeyShare, Secp256k1EncryptionKey,
    };
    use commitment::HomomorphicCommitmentScheme;
    use group::{
        secp256k1, AffineXCoordinate, GroupElement as _, HashToGroup, KnownOrderGroupElement,
        OsCsRng, PartyID,
    };
    use homomorphic_encryption::{
        AdditivelyHomomorphicDecryptionKey, AdditivelyHomomorphicDecryptionKeyShare,
        AdditivelyHomomorphicEncryptionKey,
    };
    use mpc::secret_sharing::shamir::over_the_integers::secret_key_share_size_upper_bound;
    use mpc::test_helpers::{
        asynchronous_session_terminates_successfully_internal,
        asynchronous_session_with_malicious_parties_terminates_successfully_internal,
    };
    use mpc::two_party::Round;
    use mpc::{Weight, WeightedThresholdAccessStructure};
    use tiresias::{
        test_helpers::{deal_trusted_shares, BASE, N, SECRET_KEY},
        DecryptionKeyShare,
    };

    use crate::dkg::centralized_party::{PublicKeyShareAndProof, SecretKeyShare};
    use crate::dkg::tests::{
        deals_trusted_shares_internal, generates_distributed_key_internal, mock_dkg_output,
    };
    use crate::languages::KnowledgeOfDiscreteLogUCProof;
    use crate::presign::tests::{generates_presignatures_internal, mock_presign};
    use crate::test_helpers::{setup_class_groups_secp256k1, setup_paillier_secp256k1};
    use crate::{paillier::EncryptionKey, ProtocolPublicParameters};

    use super::*;

    const MESSAGE: &str = "singing!";

    pub fn signs_internal_generic<
        const SCALAR_LIMBS: usize,
        const PLAINTEXT_SPACE_SCALAR_LIMBS: usize,
        GroupElement: PrimeGroupElement<SCALAR_LIMBS> + AffineXCoordinate<SCALAR_LIMBS> + HashToGroup,
        EncryptionKey: AdditivelyHomomorphicEncryptionKey<PLAINTEXT_SPACE_SCALAR_LIMBS>,
        P,
    >(
        presign_session_id: CommitmentSizedNumber,
        access_structure: WeightedThresholdAccessStructure,
        m: GroupElement::Scalar,
        centralized_party_secret_key_share: SecretKeyShare<group::Value<GroupElement::Scalar>>,
        centralized_party_dkg_output: P::CentralizedPartyDKGPublicOutput,
        decentralized_party_dkg_output: P::DecentralizedPartyDKGOutput,
        presign: P::Presign,
        decryption_key_share_public_parameters: P::DecryptionKeySharePublicParameters,
        tangible_party_id_to_virtual_party_id_to_decryption_key_share: HashMap<
            PartyID,
            HashMap<PartyID, P::DecryptionKeyShare>,
        >,
        protocol_public_parameters: P::ProtocolPublicParameters,
        description: String,
        malicious_parties: HashSet<PartyID>,
        bench: bool,
        expected_case: bool,
    ) -> (GroupElement, GroupElement::Scalar, GroupElement::Scalar)
    where
        P: Protocol<
            HashedMessage = GroupElement::Scalar,
            Signature = (GroupElement::Scalar, GroupElement::Scalar),
            CentralizedPartySecretKeyShare = SecretKeyShare<group::Value<GroupElement::Scalar>>,
            CentralizedPartyDKGPublicOutput = dkg::centralized_party::PublicOutput<
                group::Value<GroupElement>,
            >,
        >,
        P::ProtocolPublicParameters: AsRef<
            ProtocolPublicParameters<
                group::PublicParameters<group::Scalar<SCALAR_LIMBS, GroupElement>>,
                group::PublicParameters<GroupElement>,
                EncryptionKey::PublicParameters,
            >,
        >,
        <<P as Protocol>::SignDecentralizedParty as mpc::Party>::Message: Send + Sync,
        GroupElement::Scalar: Send + Sync,
    {
        let measurement = WallTime;
        let mut centralized_party_total_time = Duration::ZERO;

        let centralized_party_public_input = P::SignCentralizedPartyPublicInput::from((
            m,
            centralized_party_dkg_output.clone(),
            presign.clone(),
            protocol_public_parameters.clone(),
        ));
        let now = measurement.start();
        let sign_message = P::SignCentralizedParty::advance(
            (),
            &centralized_party_secret_key_share,
            &centralized_party_public_input,
            &mut OsCsRng,
        )
        .unwrap()
        .outgoing_message;

        centralized_party_total_time =
            measurement.add(&centralized_party_total_time, &measurement.end(now));

        let parties: Vec<PartyID> = access_structure
            .party_to_virtual_parties()
            .keys()
            .copied()
            .collect();

        let mut expected_decrypters = HashSet::new();
        let delta;
        let mut current_tangible_party_id = 1;
        loop {
            if !malicious_parties.contains(&current_tangible_party_id) {
                expected_decrypters.insert(current_tangible_party_id);
                let virtual_parties = access_structure
                    .virtual_subset(expected_decrypters.clone())
                    .unwrap();
                if virtual_parties.len() >= access_structure.threshold as usize {
                    delta = virtual_parties.len() as PartyID - access_structure.threshold;
                    break;
                }
            }
            current_tangible_party_id += 1;
        }

        let subset = if expected_case {
            expected_decrypters.clone()
        } else {
            let mut subset = expected_decrypters.clone();
            // We just passed the threshold using the last party id, so without it we don't pass it.
            subset.remove(&current_tangible_party_id);

            // Now add a different one to close the gap, ensuring we are in the non-expected case.
            current_tangible_party_id += 1;
            loop {
                assert!(current_tangible_party_id <= access_structure.number_of_tangible_parties());

                if !malicious_parties.contains(&current_tangible_party_id) {
                    subset.insert(current_tangible_party_id);
                    let virtual_parties = access_structure.virtual_subset(subset.clone()).unwrap();
                    if virtual_parties.len() >= access_structure.threshold as usize {
                        break;
                    }
                }
                current_tangible_party_id += 1;
            }

            subset
        };

        let parties_per_round = if malicious_parties.is_empty() {
            HashMap::from([(1, subset)])
        } else {
            HashMap::from([(1, subset.clone()), (2, subset)])
        };

        let decentralized_party_public_inputs: HashMap<
            PartyID,
            P::SignDecentralizedPartyPublicInput,
        > = parties
            .into_iter()
            .map(|party_id| {
                (
                    party_id,
                    (
                        expected_decrypters.clone(),
                        protocol_public_parameters.clone(),
                        m,
                        decentralized_party_dkg_output.clone(),
                        presign.clone(),
                        sign_message.clone(),
                        decryption_key_share_public_parameters.clone(),
                    )
                        .into(),
                )
            })
            .collect();

        let (
            decentralized_party_time,
            decentralized_party_times,
            (nonce_x_coordinate, signature_s),
        ) = asynchronous_session_with_malicious_parties_terminates_successfully_internal::<
            P::SignDecentralizedParty,
            P::SignDecentralizedParty,
        >(
            presign_session_id,
            &access_structure,
            tangible_party_id_to_virtual_party_id_to_decryption_key_share,
            decentralized_party_public_inputs.clone(),
            HashMap::from([(2, malicious_parties.clone())]),
            if malicious_parties.is_empty() { 2 } else { 3 },
            parties_per_round,
            true,
            false,
        );

        let public_key = GroupElement::new(
            centralized_party_dkg_output.public_key,
            &protocol_public_parameters.as_ref().group_public_parameters,
        )
        .unwrap();

        assert!(
            verify_signature(nonce_x_coordinate, signature_s, m, public_key).is_ok(),
            "outputted signature must verify"
        );

        let number_of_tangible_parties = access_structure.number_of_tangible_parties();
        let number_of_virtual_parties = access_structure.number_of_virtual_parties();
        let threshold = access_structure.threshold;

        if bench {
            println!(
                "{description} Sign {} (delta {delta}), {number_of_tangible_parties}, {number_of_virtual_parties}, {threshold}, 1, {:?}, {:?}, {:?}, {:?}",
                if expected_case {"expected"} else {"unexpected"},
                centralized_party_total_time.as_millis(),
                decentralized_party_time.as_millis(),
                decentralized_party_times[0].as_millis(),
                decentralized_party_times[1].as_millis()
            );
        }

        (public_key, nonce_x_coordinate, signature_s)
    }

    #[rstest]
    #[case(2, HashMap::from([(1, 1), (2, 1)]), false)]
    #[case(2, HashMap::from([(1, 1), (2, 1)]), true)]
    #[case(4, HashMap::from([(1, 2), (2, 1), (3, 3)]), false)]
    #[case(4, HashMap::from([(1, 2), (2, 1), (3, 3)]), true)]
    #[cfg(feature = "class_groups")]
    fn dkg_presign_signs_async_class_groups_secp256k1(
        #[case] threshold: PartyID,
        #[case] party_to_weight: HashMap<PartyID, Weight>,
        #[case] is_trusted_dealer: bool,
    ) {
        dkg_presign_signs_async_class_groups_secp256k1_internal(
            threshold,
            party_to_weight,
            is_trusted_dealer,
        )
    }

    pub(crate) fn dkg_presign_signs_async_class_groups_secp256k1_internal(
        threshold: PartyID,
        party_to_weight: HashMap<PartyID, Weight>,
        is_trusted_dealer: bool,
    ) {
        let access_structure =
            WeightedThresholdAccessStructure::new(threshold, party_to_weight.clone()).unwrap();

        let (protocol_public_parameters, decryption_key) = setup_class_groups_secp256k1();

        let secret_key_bits = protocol_public_parameters
            .encryption_scheme_public_parameters
            .randomness_space_public_parameters()
            .sample_bits;

        let base = protocol_public_parameters
            .encryption_scheme_public_parameters
            .setup_parameters
            .h;

        let (decryption_key_share_public_parameters, decryption_key_shares) =
            ::class_groups::test_helpers::deal_trusted_shares::<
                { U256::LIMBS },
                { crate::secp256k1::class_groups::FUNDAMENTAL_DISCRIMINANT_LIMBS },
                { crate::secp256k1::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS },
                secp256k1::GroupElement,
            >(
                threshold,
                access_structure.number_of_virtual_parties(),
                protocol_public_parameters
                    .encryption_scheme_public_parameters
                    .clone(),
                decryption_key.decryption_key,
                base,
                secret_key_bits,
            );

        let decryption_key_shares: HashMap<_, _> = decryption_key_shares
            .into_iter()
            .map(|(party_id, share)| {
                (
                    party_id,
                    Secp256k1DecryptionKeyShare::new(
                        party_id,
                        share,
                        &decryption_key_share_public_parameters,
                        &mut OsCsRng,
                    )
                    .unwrap(),
                )
            })
            .collect();

        let (dkg_session_id, access_structure) =
            crate::dkg::tests::setup_session(threshold, party_to_weight);

        let party_to_virtual_parties = access_structure.party_to_virtual_parties();
        let tangible_party_id_to_virtual_party_id_to_decryption_key_share: HashMap<
            _,
            HashMap<_, _>,
        > = access_structure
            .party_to_virtual_parties()
            .keys()
            .map(|&tangible_party_id| {
                let virtual_parties = party_to_virtual_parties
                    .get(&tangible_party_id)
                    .cloned()
                    .unwrap();

                (
                    tangible_party_id,
                    decryption_key_shares
                        .clone()
                        .into_iter()
                        .filter(|(party_id, _)| virtual_parties.contains(party_id))
                        .collect(),
                )
            })
            .collect();

        let m = bits2field::<k256::Secp256k1>(
            &<k256::Secp256k1 as DigestAlgorithm>::Digest::new_with_prefix(MESSAGE.as_bytes())
                .finalize_fixed(),
        )
        .unwrap();

        let m = <Scalar<k256::Secp256k1> as Reduce<U256>>::reduce_bytes(&m);
        let m = U256::from(m).into();

        let (public_key, nonce_x_coordinate, signature_s) = dkg_presign_signs_internal::<
            { secp256k1::SCALAR_LIMBS },
            { secp256k1::SCALAR_LIMBS },
            secp256k1::GroupElement,
            Secp256k1EncryptionKey,
            Secp256k1DecryptionKey,
            crate::secp256k1::class_groups::AsyncProtocol,
        >(
            dkg_session_id,
            access_structure,
            m,
            decryption_key,
            decryption_key_share_public_parameters,
            tangible_party_id_to_virtual_party_id_to_decryption_key_share,
            protocol_public_parameters,
            is_trusted_dealer,
            "Class Groups Asynchronous secp256k1".to_string(),
        );

        let signature_s_inner: k256::Scalar = signature_s.into();

        let signature =
            Signature::from_scalars(k256::Scalar::from(nonce_x_coordinate), signature_s_inner)
                .unwrap();

        let verifying_key =
            VerifyingKey::<k256::Secp256k1>::from_affine(public_key.value().into()).unwrap();

        let res = <VerifyingKey<k256::Secp256k1> as Verifier<Signature<k256::Secp256k1>>>::verify(
            &verifying_key,
            MESSAGE.as_bytes(),
            &signature,
        );

        assert!(res.is_ok(), "generated signatures should be valid");
    }

    #[rstest]
    #[case(2, HashMap::from([(1, 1), (2, 1)]))]
    #[case(4, HashMap::from([(1, 2), (2, 1), (3, 3)]))]
    #[cfg(feature = "class_groups")]
    fn signs_async_class_groups_secp256k1(
        #[case] threshold: PartyID,
        #[case] party_to_weight: HashMap<PartyID, Weight>,
    ) {
        signs_async_class_groups_secp256k1_internal(
            threshold,
            party_to_weight,
            HashSet::new(),
            false,
            true,
        )
    }

    #[rstest]
    #[case(3, HashMap::from([(1, 1), (2, 2), (3, 2)]), HashSet::from([1]))]
    #[case(4, HashMap::from([(1, 2), (2, 2), (3, 2)]), HashSet::from([1]))]
    #[case(6, HashMap::from([(1, 1), (2, 2), (3, 3), (4, 1), (5, 3)]), HashSet::from([2, 4]))]
    #[case(10, HashMap::from([(1, 1), (2, 2), (3, 3), (4, 1), (5, 3), (6,6), (7, 1), (8, 1), (9, 1), (10, 1), (11, 3)]), HashSet::from([5, 7]))]
    #[cfg(feature = "class_groups")]
    fn signs_async_with_malicious_class_groups_secp256k1(
        #[case] threshold: PartyID,
        #[case] party_to_weight: HashMap<PartyID, Weight>,
        #[case] malicious_parties: HashSet<PartyID>,
    ) {
        signs_async_class_groups_secp256k1_internal(
            threshold,
            party_to_weight,
            malicious_parties,
            false,
            true,
        );
    }

    #[rstest]
    #[case(8, HashMap::from([(1, 1), (2, 2), (3, 3), (4, 1), (5, 3), (6,6), (7, 1), (8, 1)]), HashSet::from([5, 7]))]
    #[cfg(feature = "class_groups")]
    fn signs_async_unexpected_with_malicious_class_groups_secp256k1(
        #[case] threshold: PartyID,
        #[case] party_to_weight: HashMap<PartyID, Weight>,
        #[case] malicious_parties: HashSet<PartyID>,
    ) {
        signs_async_class_groups_secp256k1_internal(
            threshold,
            party_to_weight,
            malicious_parties,
            false,
            false,
        );
    }

    #[cfg(feature = "class_groups")]
    pub(crate) fn signs_async_class_groups_secp256k1_internal(
        threshold: PartyID,
        party_to_weight: HashMap<PartyID, Weight>,
        malicious_parties: HashSet<PartyID>,
        bench: bool,
        expected_case: bool,
    ) {
        let access_structure =
            WeightedThresholdAccessStructure::new(threshold, party_to_weight.clone()).unwrap();

        let (protocol_public_parameters, decryption_key) = setup_class_groups_secp256k1();

        let secret_key_bits = protocol_public_parameters
            .encryption_scheme_public_parameters
            .randomness_space_public_parameters()
            .sample_bits;

        let base = protocol_public_parameters
            .encryption_scheme_public_parameters
            .setup_parameters
            .h;

        let (decryption_key_share_public_parameters, decryption_key_shares) =
            ::class_groups::test_helpers::deal_trusted_shares::<
                { U256::LIMBS },
                { crate::secp256k1::class_groups::FUNDAMENTAL_DISCRIMINANT_LIMBS },
                { crate::secp256k1::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS },
                secp256k1::GroupElement,
            >(
                threshold,
                access_structure.number_of_virtual_parties(),
                protocol_public_parameters
                    .encryption_scheme_public_parameters
                    .clone(),
                decryption_key.decryption_key,
                base,
                secret_key_bits,
            );

        let decryption_key_shares: Vec<_> = decryption_key_shares
            .into_iter()
            .map(|(virtual_party_id, decryption_key_share)| {
                let decryption_key_share = if malicious_parties.contains(
                    &access_structure
                        .to_tangible_party_id(virtual_party_id)
                        .unwrap(),
                ) {
                    let wrong_share = Uint::random(&mut OsCsRng);
                    let wrong_share = wrong_share
                        & (Uint::ONE
                            << secret_key_share_size_upper_bound(
                                u32::from(access_structure.number_of_virtual_parties()),
                                u32::from(access_structure.threshold),
                                secret_key_bits,
                            ));

                    Int::new_from_abs_sign(
                        wrong_share,
                        ConstChoice::from(Choice::from(u8::from(virtual_party_id % 2 == 0))),
                    )
                    .unwrap()
                } else {
                    decryption_key_share
                };

                (virtual_party_id, decryption_key_share)
            })
            .collect();

        let decryption_key_shares: HashMap<_, _> = decryption_key_shares
            .into_iter()
            .map(|(party_id, share)| {
                (
                    party_id,
                    Secp256k1DecryptionKeyShare::new(
                        party_id,
                        share,
                        &decryption_key_share_public_parameters,
                        &mut OsCsRng,
                    )
                    .unwrap(),
                )
            })
            .collect();

        let access_structure =
            WeightedThresholdAccessStructure::new(threshold, party_to_weight).unwrap();

        let party_to_virtual_parties = access_structure.party_to_virtual_parties();
        let tangible_party_id_to_virtual_party_id_to_decryption_key_share: HashMap<
            _,
            HashMap<_, _>,
        > = party_to_virtual_parties
            .keys()
            .map(|&tangible_party_id| {
                let virtual_parties = party_to_virtual_parties
                    .get(&tangible_party_id)
                    .cloned()
                    .unwrap();
                (
                    tangible_party_id,
                    decryption_key_shares
                        .clone()
                        .into_iter()
                        .filter(|(party_id, _)| virtual_parties.contains(party_id))
                        .collect(),
                )
            })
            .collect();

        let m = bits2field::<k256::Secp256k1>(
            &<k256::Secp256k1 as DigestAlgorithm>::Digest::new_with_prefix(MESSAGE.as_bytes())
                .finalize_fixed(),
        )
        .unwrap();

        let m = <Scalar<k256::Secp256k1> as Reduce<U256>>::reduce_bytes(&m);
        let m = U256::from(m).into();

        let (
            centralized_party_dkg_output,
            centralized_party_secret_key_share,
            decentralized_party_dkg_output,
        ) = mock_dkg_output::<
            { secp256k1::SCALAR_LIMBS },
            { secp256k1::SCALAR_LIMBS },
            secp256k1::GroupElement,
            ::class_groups::EncryptionKey<
                { secp256k1::SCALAR_LIMBS },
                { crate::secp256k1::class_groups::FUNDAMENTAL_DISCRIMINANT_LIMBS },
                { crate::secp256k1::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS },
                secp256k1::GroupElement,
            >,
        >(&protocol_public_parameters);

        let presign_session_id = CommitmentSizedNumber::random(&mut OsCsRng);

        let presign = mock_presign::<
            { secp256k1::SCALAR_LIMBS },
            { secp256k1::SCALAR_LIMBS },
            secp256k1::GroupElement,
            ::class_groups::EncryptionKey<
                { secp256k1::SCALAR_LIMBS },
                { crate::secp256k1::class_groups::FUNDAMENTAL_DISCRIMINANT_LIMBS },
                { crate::secp256k1::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS },
                secp256k1::GroupElement,
            >,
        >(
            presign_session_id,
            decentralized_party_dkg_output.clone(),
            &protocol_public_parameters,
        );

        let (public_key, nonce_x_coordinate, signature_s) = signs_internal_generic::<
            { secp256k1::SCALAR_LIMBS },
            { secp256k1::SCALAR_LIMBS },
            secp256k1::GroupElement,
            ::class_groups::EncryptionKey<
                { secp256k1::SCALAR_LIMBS },
                { crate::secp256k1::class_groups::FUNDAMENTAL_DISCRIMINANT_LIMBS },
                { crate::secp256k1::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS },
                secp256k1::GroupElement,
            >,
            crate::secp256k1::class_groups::AsyncProtocol,
        >(
            presign_session_id,
            access_structure,
            m,
            centralized_party_secret_key_share,
            centralized_party_dkg_output,
            decentralized_party_dkg_output,
            presign,
            decryption_key_share_public_parameters,
            tangible_party_id_to_virtual_party_id_to_decryption_key_share,
            protocol_public_parameters,
            "Class Groups Asynchronous secp256k1".to_string(),
            malicious_parties,
            bench,
            expected_case,
        );

        let signature_s_inner: k256::Scalar = signature_s.into();

        let signature =
            Signature::from_scalars(k256::Scalar::from(nonce_x_coordinate), signature_s_inner)
                .unwrap();

        let verifying_key =
            VerifyingKey::<k256::Secp256k1>::from_affine(public_key.value().into()).unwrap();

        let res = <VerifyingKey<k256::Secp256k1> as Verifier<Signature<k256::Secp256k1>>>::verify(
            &verifying_key,
            MESSAGE.as_bytes(),
            &signature,
        );

        assert!(res.is_ok(), "generated signatures should be valid");
    }

    #[rstest]
    #[case(2, HashMap::from([(1, 1), (2, 1)]), false)]
    #[case(2, HashMap::from([(1, 1), (2, 1)]), true)]
    #[case(4, HashMap::from([(1, 2), (2, 1), (3, 3)]), false)]
    #[case(4, HashMap::from([(1, 2), (2, 1), (3, 3)]), true)]
    #[cfg(all(feature = "paillier", feature = "bulletproofs",))]
    pub(crate) fn dkg_presign_signs_async_paillier_secp256k11(
        #[case] threshold: PartyID,
        #[case] party_to_weight: HashMap<PartyID, Weight>,
        #[case] is_trusted_dealer: bool,
    ) {
        dkg_presign_signs_async_paillier_secp256k1_internal(
            threshold,
            party_to_weight,
            is_trusted_dealer,
        )
    }

    #[cfg(all(feature = "paillier", feature = "bulletproofs",))]
    pub(crate) fn dkg_presign_signs_async_paillier_secp256k1_internal(
        threshold: PartyID,
        party_to_weight: HashMap<PartyID, Weight>,
        is_trusted_dealer: bool,
    ) {
        let access_structure =
            WeightedThresholdAccessStructure::new(threshold, party_to_weight.clone()).unwrap();

        let (paillier_protocol_public_parameters, decryption_key) = setup_paillier_secp256k1();
        let (decryption_key_share_public_parameters, decryption_key_shares) = deal_trusted_shares(
            threshold,
            access_structure.number_of_virtual_parties(),
            N,
            SECRET_KEY,
            BASE,
        );

        let decryption_key_shares: HashMap<_, _> = decryption_key_shares
            .into_iter()
            .map(|(party_id, share)| {
                (
                    party_id,
                    DecryptionKeyShare::new(
                        party_id,
                        share,
                        &decryption_key_share_public_parameters,
                        &mut OsCsRng,
                    )
                    .unwrap(),
                )
            })
            .collect();

        let (dkg_session_id, access_structure) =
            crate::dkg::tests::setup_session(threshold, party_to_weight);

        let party_to_virtual_parties = access_structure.party_to_virtual_parties();
        let tangible_party_id_to_virtual_party_id_to_decryption_key_share: HashMap<
            _,
            HashMap<_, _>,
        > = access_structure
            .party_to_virtual_parties()
            .keys()
            .map(|&tangible_party_id| {
                let virtual_parties = party_to_virtual_parties
                    .get(&tangible_party_id)
                    .cloned()
                    .unwrap();
                (
                    tangible_party_id,
                    decryption_key_shares
                        .clone()
                        .into_iter()
                        .filter(|(party_id, _)| virtual_parties.contains(party_id))
                        .collect(),
                )
            })
            .collect();

        let m = bits2field::<k256::Secp256k1>(
            &<k256::Secp256k1 as DigestAlgorithm>::Digest::new_with_prefix(MESSAGE.as_bytes())
                .finalize_fixed(),
        )
        .unwrap();

        let m = <Scalar<k256::Secp256k1> as Reduce<U256>>::reduce_bytes(&m);
        let m = U256::from(m).into();

        let (public_key, nonce_x_coordinate, signature_s) = dkg_presign_signs_internal::<
            { secp256k1::SCALAR_LIMBS },
            { crate::paillier::PLAINTEXT_SPACE_SCALAR_LIMBS },
            secp256k1::GroupElement,
            tiresias::EncryptionKey,
            tiresias::DecryptionKey,
            crate::secp256k1::paillier::bulletproofs::AsyncProtocol,
        >(
            dkg_session_id,
            access_structure,
            m,
            decryption_key,
            decryption_key_share_public_parameters,
            tangible_party_id_to_virtual_party_id_to_decryption_key_share,
            paillier_protocol_public_parameters,
            is_trusted_dealer,
            "Paillier Asynchronous secp256k1".to_string(),
        );

        let signature_s_inner: k256::Scalar = signature_s.into();

        let signature =
            Signature::from_scalars(k256::Scalar::from(nonce_x_coordinate), signature_s_inner)
                .unwrap();

        let verifying_key =
            VerifyingKey::<k256::Secp256k1>::from_affine(public_key.value().into()).unwrap();

        let res = <VerifyingKey<k256::Secp256k1> as Verifier<Signature<k256::Secp256k1>>>::verify(
            &verifying_key,
            MESSAGE.as_bytes(),
            &signature,
        );

        assert!(res.is_ok(), "generated signatures should be valid");
    }

    #[rstest]
    #[case(2, HashMap::from([(1, 1), (2, 1)]))]
    #[case(4, HashMap::from([(1, 2), (2, 1), (3, 3)]))]
    #[cfg(all(feature = "paillier", feature = "bulletproofs",))]
    pub(crate) fn signs_async_paillier_secp256k1(
        #[case] threshold: PartyID,
        #[case] party_to_weight: HashMap<PartyID, Weight>,
    ) {
        signs_async_paillier_secp256k1_internal(
            threshold,
            party_to_weight,
            HashSet::new(),
            false,
            true,
        )
    }

    #[rstest]
    #[case(3, HashMap::from([(1, 1), (2, 2), (3, 2)]), HashSet::from([1]))]
    #[case(4, HashMap::from([(1, 2), (2, 2), (3, 2)]), HashSet::from([1]))]
    #[case(6, HashMap::from([(1, 1), (2, 2), (3, 3), (4, 1), (5, 4)]), HashSet::from([2, 3]))]
    #[case(10, HashMap::from([(1, 1), (2, 2), (3, 3), (4, 1), (5, 3), (6,2), (7, 3), (8, 1), (9, 1)]), HashSet::from([1, 7]))]
    #[cfg(all(feature = "paillier", feature = "bulletproofs",))]
    fn signs_async_with_malicious_paillier_secp256k1(
        #[case] threshold: PartyID,
        #[case] party_to_weight: HashMap<PartyID, Weight>,
        #[case] malicious_parties: HashSet<PartyID>,
    ) {
        signs_async_paillier_secp256k1_internal(
            threshold,
            party_to_weight.clone(),
            malicious_parties.clone(),
            false,
            true,
        );
    }

    #[rstest]
    #[case(7, HashMap::from([(1, 1), (2, 2), (3, 3), (4, 1), (5, 3), (6,2), (7, 4)]), HashSet::from([1, 2]))]
    #[cfg(all(feature = "paillier", feature = "bulletproofs",))]
    fn signs_async_unexpected_with_malicious_paillier_secp256k1(
        #[case] threshold: PartyID,
        #[case] party_to_weight: HashMap<PartyID, Weight>,
        #[case] malicious_parties: HashSet<PartyID>,
    ) {
        signs_async_paillier_secp256k1_internal(
            threshold,
            party_to_weight.clone(),
            malicious_parties.clone(),
            false,
            false,
        );
    }

    #[cfg(all(feature = "paillier", feature = "bulletproofs",))]
    pub(crate) fn signs_async_paillier_secp256k1_internal(
        threshold: PartyID,
        party_to_weight: HashMap<PartyID, Weight>,
        malicious_parties: HashSet<PartyID>,
        bench: bool,
        expected_case: bool,
    ) {
        let access_structure =
            WeightedThresholdAccessStructure::new(threshold, party_to_weight.clone()).unwrap();

        let (paillier_protocol_public_parameters, _) = setup_paillier_secp256k1();
        let (decryption_key_share_public_parameters, decryption_key_shares) = deal_trusted_shares(
            threshold,
            access_structure.number_of_virtual_parties(),
            N,
            SECRET_KEY,
            BASE,
        );

        let decryption_key_shares: Vec<_> = decryption_key_shares
            .into_iter()
            .map(|(party_id, decryption_key_share)| {
                let decryption_key_share = if malicious_parties
                    .contains(&access_structure.to_tangible_party_id(party_id).unwrap())
                {
                    let wrong_share = if party_id % 2 == 0 {
                        Uint::random(&mut OsCsRng)
                    } else {
                        Uint::default()
                    };
                    wrong_share
                        & (Uint::ONE
                            << secret_key_share_size_upper_bound(
                                u32::from(access_structure.number_of_virtual_parties()),
                                u32::from(access_structure.threshold),
                                U4096::BITS,
                            ))
                } else {
                    decryption_key_share
                };

                (party_id, decryption_key_share)
            })
            .collect();

        let decryption_key_shares: HashMap<_, _> = decryption_key_shares
            .into_iter()
            .map(|(party_id, share)| {
                (
                    party_id,
                    DecryptionKeyShare::new(
                        party_id,
                        share,
                        &decryption_key_share_public_parameters,
                        &mut OsCsRng,
                    )
                    .unwrap(),
                )
            })
            .collect();
        let (_, access_structure) = crate::dkg::tests::setup_session(threshold, party_to_weight);

        let party_to_virtual_parties = access_structure.party_to_virtual_parties();
        let tangible_party_id_to_virtual_party_id_to_decryption_key_share: HashMap<
            _,
            HashMap<_, _>,
        > = party_to_virtual_parties
            .keys()
            .map(|&tangible_party_id| {
                let virtual_parties = party_to_virtual_parties
                    .get(&tangible_party_id)
                    .cloned()
                    .unwrap();
                (
                    tangible_party_id,
                    decryption_key_shares
                        .clone()
                        .into_iter()
                        .filter(|(party_id, _)| virtual_parties.contains(party_id))
                        .collect(),
                )
            })
            .collect();

        let m = bits2field::<k256::Secp256k1>(
            &<k256::Secp256k1 as DigestAlgorithm>::Digest::new_with_prefix(MESSAGE.as_bytes())
                .finalize_fixed(),
        )
        .unwrap();

        let m = <Scalar<k256::Secp256k1> as Reduce<U256>>::reduce_bytes(&m);
        let m = U256::from(m).into();

        let (
            centralized_party_dkg_output,
            centralized_party_secret_key_share,
            decentralized_party_dkg_output,
        ) = mock_dkg_output::<
            { secp256k1::SCALAR_LIMBS },
            { crate::paillier::PLAINTEXT_SPACE_SCALAR_LIMBS },
            secp256k1::GroupElement,
            EncryptionKey,
        >(&paillier_protocol_public_parameters.protocol_public_parameters);

        let presign_session_id = CommitmentSizedNumber::random(&mut OsCsRng);

        let presign = mock_presign::<
            { secp256k1::SCALAR_LIMBS },
            { crate::paillier::PLAINTEXT_SPACE_SCALAR_LIMBS },
            secp256k1::GroupElement,
            EncryptionKey,
        >(
            presign_session_id,
            decentralized_party_dkg_output.clone(),
            &paillier_protocol_public_parameters.protocol_public_parameters,
        );

        let (public_key, nonce_x_coordinate, signature_s) = signs_internal_generic::<
            { secp256k1::SCALAR_LIMBS },
            { crate::paillier::PLAINTEXT_SPACE_SCALAR_LIMBS },
            secp256k1::GroupElement,
            tiresias::EncryptionKey,
            crate::secp256k1::paillier::bulletproofs::AsyncProtocol,
        >(
            presign_session_id,
            access_structure,
            m,
            centralized_party_secret_key_share,
            centralized_party_dkg_output,
            decentralized_party_dkg_output,
            presign,
            decryption_key_share_public_parameters,
            tangible_party_id_to_virtual_party_id_to_decryption_key_share,
            paillier_protocol_public_parameters,
            "Paillier Asynchronous secp256k1".to_string(),
            malicious_parties,
            bench,
            expected_case,
        );

        let signature_s_inner: k256::Scalar = signature_s.into();

        let signature =
            Signature::from_scalars(k256::Scalar::from(nonce_x_coordinate), signature_s_inner)
                .unwrap();

        let verifying_key =
            VerifyingKey::<k256::Secp256k1>::from_affine(public_key.value().into()).unwrap();

        let res = <VerifyingKey<k256::Secp256k1> as Verifier<Signature<k256::Secp256k1>>>::verify(
            &verifying_key,
            MESSAGE.as_bytes(),
            &signature,
        );

        assert!(res.is_ok(), "generated signatures should be valid");
    }

    fn dkg_presign_signs_internal<
        const SCALAR_LIMBS: usize,
        const PLAINTEXT_SPACE_SCALAR_LIMBS: usize,
        GroupElement: PrimeGroupElement<SCALAR_LIMBS> + AffineXCoordinate<SCALAR_LIMBS> + HashToGroup,
        EncryptionKey: AdditivelyHomomorphicEncryptionKey<PLAINTEXT_SPACE_SCALAR_LIMBS>,
        DecryptionKey: AdditivelyHomomorphicDecryptionKey<PLAINTEXT_SPACE_SCALAR_LIMBS, EncryptionKey>,
        P,
    >(
        dkg_session_id: CommitmentSizedNumber,
        access_structure: WeightedThresholdAccessStructure,
        m: GroupElement::Scalar,
        decryption_key: DecryptionKey,
        decryption_key_share_public_parameters: P::DecryptionKeySharePublicParameters,
        tangible_party_id_to_virtual_party_id_to_decryption_key_share: HashMap<
            PartyID,
            HashMap<PartyID, P::DecryptionKeyShare>,
        >,
        protocol_public_parameters: P::ProtocolPublicParameters,
        is_trusted_dealer: bool,
        description: String,
    ) -> (GroupElement, GroupElement::Scalar, GroupElement::Scalar)
    where
        GroupElement::Scalar: From<Uint<PLAINTEXT_SPACE_SCALAR_LIMBS>>,
        P: Protocol<
            CentralizedPartyDKGPublicOutput = crate::dkg::centralized_party::PublicOutput<
                group::Value<GroupElement>,
            >,
            CentralizedPartySecretKeyShare = SecretKeyShare<group::Value<GroupElement::Scalar>>,
            DecentralizedPartyDKGOutput = crate::dkg::decentralized_party::Output<
                GroupElement::Value,
                group::Value<EncryptionKey::CiphertextSpaceGroupElement>,
            >,
            PublicKeyShareAndProof = PublicKeyShareAndProof<
                group::Value<GroupElement>,
                KnowledgeOfDiscreteLogUCProof<SCALAR_LIMBS, GroupElement>,
            >,
            Presign = Presign<
                GroupElement::Value,
                group::Value<EncryptionKey::CiphertextSpaceGroupElement>,
            >,
            HashedMessage = GroupElement::Scalar,
            Signature = (GroupElement::Scalar, GroupElement::Scalar),
            SecretKey = group::Value<GroupElement::Scalar>,
        >,
        P::ProtocolPublicParameters: AsRef<
            ProtocolPublicParameters<
                group::PublicParameters<group::Scalar<SCALAR_LIMBS, GroupElement>>,
                group::PublicParameters<GroupElement>,
                EncryptionKey::PublicParameters,
            >,
        >,
    {
        let (
            centralized_party_dkg_output,
            centralized_party_secret_key_share,
            decentralized_party_dkg_output,
        ) = if is_trusted_dealer {
            deals_trusted_shares_internal::<
                SCALAR_LIMBS,
                PLAINTEXT_SPACE_SCALAR_LIMBS,
                GroupElement,
                EncryptionKey,
                P,
            >(
                dkg_session_id,
                access_structure.clone(),
                protocol_public_parameters.clone(),
            )
        } else {
            generates_distributed_key_internal::<
                SCALAR_LIMBS,
                PLAINTEXT_SPACE_SCALAR_LIMBS,
                GroupElement,
                EncryptionKey,
                DecryptionKey,
                P,
            >(
                dkg_session_id,
                access_structure.clone(),
                protocol_public_parameters.clone(),
                decryption_key,
                description.clone(),
            )
        };
        let parties: Vec<PartyID> = access_structure
            .party_to_virtual_parties()
            .keys()
            .copied()
            .collect();
        let encryption_of_mask_and_masked_key_share_round_public_inputs = parties
            .into_iter()
            .map(|party_id| {
                (
                    party_id,
                    (
                        protocol_public_parameters.clone(),
                        decentralized_party_dkg_output.clone(),
                    )
                        .into(),
                )
            })
            .collect();

        let presign_session_id = CommitmentSizedNumber::random(&mut OsCsRng);
        let presign = generates_presignatures_internal::<
            SCALAR_LIMBS,
            PLAINTEXT_SPACE_SCALAR_LIMBS,
            GroupElement,
            EncryptionKey,
            P,
        >(
            presign_session_id,
            access_structure.clone(),
            encryption_of_mask_and_masked_key_share_round_public_inputs,
            description.clone(),
        );

        signs_internal_generic::<
            SCALAR_LIMBS,
            PLAINTEXT_SPACE_SCALAR_LIMBS,
            GroupElement,
            EncryptionKey,
            P,
        >(
            presign_session_id,
            access_structure,
            m,
            centralized_party_secret_key_share,
            centralized_party_dkg_output,
            decentralized_party_dkg_output,
            presign,
            decryption_key_share_public_parameters,
            tangible_party_id_to_virtual_party_id_to_decryption_key_share,
            protocol_public_parameters,
            description.clone(),
            HashSet::new(),
            false,
            true,
        )
    }
}

#[cfg(all(test, feature = "benchmarking"))]
mod benches {
    use std::collections::HashSet;

    use group::OsCsRng;
    use mpc::WeightedThresholdAccessStructure;

    #[test]
    #[ignore]
    #[allow(clippy::single_element_loop)]
    fn benchmark() {
        println!(
            "\nProtocol, Number of Parties, Threshold, Batch Size, Centralized Party Total Time (ms), Decentralized Party Total Time (ms), Decentralized Party Decryption Share Time (ms), Decentralized Party Threshold Decryption Time (ms)",
        );

        for (threshold, number_of_tangible_parties, total_weight) in [(67, 100, 100)] {
            let access_structure = WeightedThresholdAccessStructure::uniform(
                threshold,
                number_of_tangible_parties,
                total_weight,
                &mut OsCsRng,
            )
            .unwrap();

            super::tests::signs_async_class_groups_secp256k1_internal(
                access_structure.threshold,
                access_structure.party_to_weight.clone(),
                HashSet::new(),
                true,
                true,
            );

            super::tests::signs_async_class_groups_secp256k1_internal(
                access_structure.threshold,
                access_structure.party_to_weight,
                HashSet::new(),
                true,
                false,
            );
        }
    }
}
