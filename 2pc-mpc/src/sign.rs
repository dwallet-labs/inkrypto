// Author: dWallet Labs, Ltd.
// SPDX-License-Identifier: CC-BY-NC-ND-4.0

use crate::{dkg, presign};
use group::{CsRng, HashScheme, PartyID};
use mpc::{two_party, AsynchronouslyAdvanceable};
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use std::fmt::Debug;

/// An instantiation of the 2PC-MPC Sign protocol.
pub trait Protocol: dkg::Protocol + presign::Protocol {
    /// The output of the Sign protocol.
    type Signature: EncodableSignature;

    /// A decryption key share.
    type DecryptionKeyShare: Sync + Send;

    /// The decryption key share public parameters.
    type DecryptionKeySharePublicParameters: Serialize + Clone + Debug + PartialEq + Eq;

    /// The public input of the decentralized party's Sign protocol.
    type SignDecentralizedPartyPublicInput: From<(
            HashSet<PartyID>,
            Self::ProtocolPublicParameters,
            Vec<u8>,
            HashScheme,
            Self::DecentralizedPartyDKGOutput,
            Self::Presign,
            Self::SignMessage,
            Self::DecryptionKeySharePublicParameters,
        )> + Serialize
        + Clone
        + Debug
        + PartialEq
        + Eq
        + Sync
        + Send;

    /// A party participating in the decentralized party's Sign protocol.
    type SignDecentralizedParty: mpc::Party<
            PublicInput = Self::SignDecentralizedPartyPublicInput,
            PublicOutputValue = Self::Signature,
            PublicOutput = Self::Signature,
        > + AsynchronouslyAdvanceable<PrivateInput = HashMap<PartyID, Self::DecryptionKeyShare>>
        + Sync
        + Send;

    /// The public input of the decentralized party's Sign protocol.
    type DKGSignDecentralizedPartyPublicInput: From<(
            HashSet<PartyID>,
            Self::ProtocolPublicParameters,
            Vec<u8>,
            HashScheme,
            Self::DKGDecentralizedPartyPublicInput,
            Self::Presign,
            Self::SignMessage,
            Self::DecryptionKeySharePublicParameters,
        )> + Serialize
        + Clone
        + Debug
        + PartialEq
        + Eq
        + Sync
        + Send;

    /// A party participating in the decentralized party's DKG followed by a Sign protocol.
    type DKGSignDecentralizedParty: mpc::Party<
            PublicInput = Self::DKGSignDecentralizedPartyPublicInput,
            PublicOutputValue = (Self::DecentralizedPartyDKGOutput, Self::Signature),
            PublicOutput = (Self::DecentralizedPartyDKGOutput, Self::Signature),
        > + AsynchronouslyAdvanceable<PrivateInput = HashMap<PartyID, Self::DecryptionKeyShare>>
        + Sync
        + Send;

    /// The public input of the centralized party in the Sign protocol.
    type SignCentralizedPartyPublicInput: From<(
            Vec<u8>,
            HashScheme,
            Self::CentralizedPartyDKGOutput,
            Self::Presign,
            Self::ProtocolPublicParameters,
        )> + Serialize
        + Clone
        + Debug
        + PartialEq
        + Eq;

    /// The outgoing message of the centralized party in the Sign protocol.
    type SignMessage: Serialize + for<'a> Deserialize<'a> + Clone + Debug + PartialEq + Eq;

    /// The party of the centralized party in the Sign protocol.
    type SignCentralizedParty: two_party::Round<
        IncomingMessage = (),
        OutgoingMessage = Self::SignMessage,
        PrivateInput = Self::CentralizedPartySecretKeyShare,
        PrivateOutput = (),
        PublicOutput = (),
        PublicOutputValue = (),
        PublicInput = Self::SignCentralizedPartyPublicInput,
    >;

    /// This function implements step (2d) of the Sign protocol:
    /// Verifies zk-proofs of C_{k}, C_{\alpha}, C_{\beta}, C_{kx}, R, R_{B} ,\textsf{ct}_{\alpha,\beta}. and \textsf{ct}_A.
    /// src: <https://eprint.iacr.org/archive/2025/297/20250522:123428>
    /// Verify the validity of the partial signature (e.g. encrypted signature parts in ECDSA) sent by the centralized party.
    /// If this function returns `Ok()`, it means that a valid signature over `message` is
    /// guaranteed to be able to be generated by the decentralized party, whenever a threshold of
    /// honest parties decides to engage in the signing protocol.
    fn verify_centralized_party_partial_signature(
        message: &[u8],
        hash_type: HashScheme,
        dkg_output: Self::DecentralizedPartyDKGOutput,
        presign: Self::Presign,
        sign_message: Self::SignMessage,
        protocol_public_parameters: &Self::ProtocolPublicParameters,
        rng: &mut impl CsRng,
    ) -> crate::Result<()>;
}

/// An encodable signature is one that can be encoded into a fixed-size array of bytes.
pub trait EncodableSignature:
    Into<Self::Encoding>
    + Serialize
    + for<'a> Deserialize<'a>
    + Clone
    + Debug
    + PartialEq
    + Eq
    + Send
    + Sync
{
    /// An encoded signature.
    type Encoding: Copy + Send + Sync + 'static + AsRef<[u8]> + AsMut<[u8]>;

    /// Encodes the signature in its standardized representation.
    fn to_bytes(self) -> Self::Encoding {
        self.into()
    }
}

#[cfg(any(test, feature = "benchmarking"))]
#[allow(unused_imports)]
#[allow(dead_code)]
pub(crate) mod tests {
    use std::{collections::HashMap, ops::Neg, time::Duration};

    use criterion::measurement::{Measurement, WallTime};
    use crypto_bigint::subtle::Choice;
    use crypto_bigint::{ConstChoice, Encoding, Int, Random, Uint, U256, U4096};
    use curve25519_dalek::RistrettoPoint;
    use ecdsa::elliptic_curve::group::GroupEncoding;
    use ecdsa::signature::hazmat::PrehashVerifier;
    use ecdsa::{
        elliptic_curve::{ops::Reduce, Scalar},
        hazmat::{bits2field, DigestAlgorithm},
        signature::{digest::Digest, Verifier},
        Signature, VerifyingKey,
    };
    use ed25519_dalek::Verifier as _;
    use k256::sha2::digest::FixedOutput;
    use rand::prelude::IteratorRandom;
    use rstest::rstest;

    use ::class_groups::{
        Secp256k1DecryptionKey, Secp256k1DecryptionKeyShare, Secp256k1EncryptionKey,
    };
    use class_groups::{
        Curve25519DecryptionKey, Curve25519DecryptionKeyShare, Curve25519EncryptionKey,
        RistrettoDecryptionKey, RistrettoDecryptionKeyShare, RistrettoEncryptionKey,
        Secp256r1DecryptionKey, Secp256r1DecryptionKeyShare, Secp256r1EncryptionKey,
        SecretKeyShareSizedInteger,
    };
    use commitment::{CommitmentSizedNumber, HomomorphicCommitmentScheme};
    use group::{
        curve25519, hash_to_scalar, ristretto, secp256k1, secp256r1, GroupElement as _,
        HashToGroup, KnownOrderGroupElement, OsCsRng, PartyID, PrimeGroupElement,
    };
    use homomorphic_encryption::{
        AdditivelyHomomorphicDecryptionKey, AdditivelyHomomorphicDecryptionKeyShare,
        AdditivelyHomomorphicEncryptionKey, GroupsPublicParametersAccessors,
    };
    use mpc::secret_sharing::shamir::over_the_integers::secret_key_share_size_upper_bound;
    use mpc::test_helpers::{
        asynchronous_session_terminates_successfully_internal,
        asynchronous_session_with_malicious_parties_terminates_successfully_internal,
    };
    use mpc::two_party::Round;
    use mpc::{Weight, WeightedThresholdAccessStructure};

    use super::*;
    use crate::dkg::centralized_party;
    use crate::dkg::centralized_party::{PublicKeyShareAndProof, SecretKeyShare};
    use crate::dkg::tests::{
        deals_trusted_shares_internal, generates_distributed_key_internal, mock_targeted_dkg_output,
    };
    use crate::ecdsa::sign::verify_signature;
    use crate::ecdsa::{ECDSASecp256k1Signature, ECDSASecp256r1Signature};
    use crate::languages::KnowledgeOfDiscreteLogUCProof;
    use crate::presign::tests::{
        generates_presignatures_internal, mock_ecdsa_presign, mock_schnorr_presign,
    };
    use crate::schnorr::{EdDSASignature, SchnorrkelSubstrateSignature, TaprootSignature};
    use crate::secp256k1::class_groups::{ECDSAProtocol, TaprootProtocol};
    use crate::test_helpers::{
        setup_class_groups_curve25519, setup_class_groups_ristretto, setup_class_groups_secp256k1,
        setup_class_groups_secp256r1,
    };
    use crate::{schnorr, Error, ProtocolPublicParameters};

    pub(crate) const MESSAGE: &str = "singing!";

    pub fn signs_internal_generic<
        const SCALAR_LIMBS: usize,
        const PLAINTEXT_SPACE_SCALAR_LIMBS: usize,
        GroupElement: PrimeGroupElement<SCALAR_LIMBS>,
        EncryptionKey: AdditivelyHomomorphicEncryptionKey<PLAINTEXT_SPACE_SCALAR_LIMBS>,
        P,
    >(
        presign_session_id: CommitmentSizedNumber,
        access_structure: WeightedThresholdAccessStructure,
        hash_type: HashScheme,
        centralized_party_secret_key_share: SecretKeyShare<group::Value<GroupElement::Scalar>>,
        centralized_party_dkg_output: P::CentralizedPartyDKGOutput,
        decentralized_party_dkg_output: P::DecentralizedPartyDKGOutput,
        presign: P::Presign,
        decryption_key_share_public_parameters: P::DecryptionKeySharePublicParameters,
        tangible_party_id_to_virtual_party_id_to_decryption_key_share: HashMap<
            PartyID,
            HashMap<PartyID, P::DecryptionKeyShare>,
        >,
        message: &[u8],
        verify_signature: fn(
            public_key: GroupElement,
            signature: P::Signature,
            message: &[u8],
            hash_type: HashScheme,
        ) -> crate::Result<()>,
        protocol_public_parameters: P::ProtocolPublicParameters,
        description: String,
        malicious_parties: HashSet<PartyID>,
        bench: bool,
        expected_case: bool,
    ) where
        P: Protocol<
            CentralizedPartySecretKeyShare = SecretKeyShare<group::Value<GroupElement::Scalar>>,
            CentralizedPartyDKGOutput = dkg::centralized_party::VersionedOutput<
                SCALAR_LIMBS,
                group::Value<GroupElement>,
            >,
        >,
        P::ProtocolPublicParameters: AsRef<
            ProtocolPublicParameters<
                group::PublicParameters<GroupElement::Scalar>,
                GroupElement::PublicParameters,
                GroupElement::Value,
                homomorphic_encryption::CiphertextSpaceValue<
                    PLAINTEXT_SPACE_SCALAR_LIMBS,
                    EncryptionKey,
                >,
                EncryptionKey::PublicParameters,
            >,
        >,
        <<P as Protocol>::SignDecentralizedParty as mpc::Party>::Message: Send + Sync,
        GroupElement::Scalar: Send + Sync,
        Uint<SCALAR_LIMBS>: Encoding,
    {
        let measurement = WallTime;
        let mut centralized_party_total_time = Duration::ZERO;

        let centralized_party_public_input = P::SignCentralizedPartyPublicInput::from((
            message.to_vec(),
            hash_type,
            centralized_party_dkg_output.clone(),
            presign.clone(),
            protocol_public_parameters.clone(),
        ));
        let now = measurement.start();
        let sign_message = P::SignCentralizedParty::advance(
            (),
            &centralized_party_secret_key_share,
            &centralized_party_public_input,
            &mut OsCsRng,
        )
        .unwrap()
        .outgoing_message;

        centralized_party_total_time =
            measurement.add(&centralized_party_total_time, &measurement.end(now));

        let parties: Vec<PartyID> = access_structure
            .party_to_virtual_parties()
            .keys()
            .copied()
            .collect();

        let mut expected_decrypters = HashSet::new();
        let delta;
        let mut current_tangible_party_id = 1;
        loop {
            if !malicious_parties.contains(&current_tangible_party_id) {
                expected_decrypters.insert(current_tangible_party_id);
                let virtual_parties = access_structure
                    .virtual_subset(expected_decrypters.clone())
                    .unwrap();
                if virtual_parties.len() >= access_structure.threshold as usize {
                    delta = virtual_parties.len() as PartyID - access_structure.threshold;
                    break;
                }
            }
            current_tangible_party_id += 1;
        }

        let subset = if expected_case {
            expected_decrypters.clone()
        } else {
            let mut subset = expected_decrypters.clone();
            // We just passed the threshold using the last party id, so without it we don't pass it.
            subset.remove(&current_tangible_party_id);

            // Now add a different one to close the gap, ensuring we are in the non-expected case.
            current_tangible_party_id += 1;
            loop {
                assert!(current_tangible_party_id <= access_structure.number_of_tangible_parties());

                if !malicious_parties.contains(&current_tangible_party_id) {
                    subset.insert(current_tangible_party_id);
                    let virtual_parties = access_structure.virtual_subset(subset.clone()).unwrap();
                    if virtual_parties.len() >= access_structure.threshold as usize {
                        break;
                    }
                }
                current_tangible_party_id += 1;
            }

            subset
        };

        let parties_per_round = if malicious_parties.is_empty() {
            HashMap::from([(1, subset)])
        } else {
            HashMap::from([(1, subset.clone()), (2, subset)])
        };

        let decentralized_party_public_inputs: HashMap<
            PartyID,
            P::SignDecentralizedPartyPublicInput,
        > = parties
            .into_iter()
            .map(|party_id| {
                (
                    party_id,
                    (
                        expected_decrypters.clone(),
                        protocol_public_parameters.clone(),
                        message.to_vec(),
                        hash_type,
                        decentralized_party_dkg_output.clone(),
                        presign.clone(),
                        sign_message.clone(),
                        decryption_key_share_public_parameters.clone(),
                    )
                        .into(),
                )
            })
            .collect();

        let (decentralized_party_time, decentralized_party_times, signature) =
            asynchronous_session_with_malicious_parties_terminates_successfully_internal::<
                P::SignDecentralizedParty,
                P::SignDecentralizedParty,
            >(
                presign_session_id,
                &access_structure,
                tangible_party_id_to_virtual_party_id_to_decryption_key_share,
                decentralized_party_public_inputs.clone(),
                HashMap::from([(2, malicious_parties.clone())]),
                if malicious_parties.is_empty() { 2 } else { 3 },
                parties_per_round,
                true,
                false,
            );

        let centralized_party_dkg_output_inner =
            centralized_party::Output::from(centralized_party_dkg_output);

        let public_key = GroupElement::new(
            centralized_party_dkg_output_inner.public_key,
            &protocol_public_parameters.as_ref().group_public_parameters,
        )
        .unwrap();

        let res = verify_signature(public_key, signature, message, hash_type);
        assert!(
            res.is_ok(),
            "outputted signature must verify, got {:?}",
            res.err().unwrap()
        );

        let number_of_tangible_parties = access_structure.number_of_tangible_parties();
        let number_of_virtual_parties = access_structure.number_of_virtual_parties();
        let threshold = access_structure.threshold;

        if bench {
            println!(
                "{description} Sign {} (delta {delta}), {number_of_tangible_parties}, {number_of_virtual_parties}, {threshold}, 1, {:?}, {:?}, {:?}, {:?}",
                if expected_case {"expected"} else {"unexpected"},
                centralized_party_total_time.as_millis(),
                decentralized_party_time.as_millis(),
                decentralized_party_times[0].as_millis(),
                decentralized_party_times[1].as_millis()
            );
        }
    }

    #[rstest]
    #[case(2, HashMap::from([(1, 1), (2, 1)]), false)]
    #[case(2, HashMap::from([(1, 1), (2, 1)]), true)]
    #[case(4, HashMap::from([(1, 2), (2, 1), (3, 3)]), false)]
    #[case(4, HashMap::from([(1, 2), (2, 1), (3, 3)]), true)]
    fn dkg_presign_signs_ecdsa_async_class_groups_secp256r1(
        #[case] threshold: PartyID,
        #[case] party_to_weight: HashMap<PartyID, Weight>,
        #[case] is_trusted_dealer: bool,
    ) {
        dkg_presign_signs_async_class_groups_secp256r1_internal::<
            crate::secp256r1::class_groups::ECDSAProtocol,
        >(
            threshold,
            party_to_weight,
            HashScheme::SHA256,
            is_trusted_dealer,
            MESSAGE.as_bytes(),
            verify_secp256r1_ecdsa_signature,
            "Class Groups Asynchronous ECDSA secp256r1",
        )
    }


    pub(crate) fn dkg_presign_signs_async_class_groups_secp256r1_internal<P>(
        threshold: PartyID,
        party_to_weight: HashMap<PartyID, Weight>,
        hash_type: HashScheme,
        is_trusted_dealer: bool,
        message: &[u8],
        verify_signature: fn(
            public_key: secp256r1::GroupElement,
            signature: P::Signature,
            message: &[u8],
            hash_type: HashScheme,
        ) -> crate::Result<()>,
        description: &str,
    ) where
        P: Protocol<
            CentralizedPartySecretKeyShare = SecretKeyShare<group::Value<secp256r1::Scalar>>,
            CentralizedPartyDKGOutput = dkg::centralized_party::VersionedOutput<
                { secp256r1::SCALAR_LIMBS },
                group::Value<secp256r1::GroupElement>,
            >,
            DecentralizedPartyDKGOutput = crate::dkg::decentralized_party::VersionedOutput<
                { secp256r1::SCALAR_LIMBS },
                group::Value<secp256r1::GroupElement>,
                class_groups::CiphertextSpaceValue<{ crate::secp256r1::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS }>,
            >,
            DecentralizedPartyTargetedDKGOutput = crate::dkg::decentralized_party::Output<
                group::Value<secp256r1::GroupElement>,
                class_groups::CiphertextSpaceValue<{ crate::secp256r1::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS }>,
            >,
            ProtocolPublicParameters = crate::class_groups::ProtocolPublicParameters<
                { secp256r1::SCALAR_LIMBS },
                { crate::secp256r1::class_groups::FUNDAMENTAL_DISCRIMINANT_LIMBS },
                { crate::secp256r1::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS },
                secp256r1::GroupElement,
            >,
            DecryptionKeySharePublicParameters = class_groups::Secp256r1DecryptionKeySharePublicParameters,
            DecryptionKeyShare = SecretKeyShareSizedInteger,
            PublicKeyShareAndProof = PublicKeyShareAndProof<
                group::Value<secp256r1::GroupElement>,
                KnowledgeOfDiscreteLogUCProof<{ secp256r1::SCALAR_LIMBS }, secp256r1::GroupElement>,
            >,
            SecretKey = group::Value<secp256r1::Scalar>,
        >,
        <<P as Protocol>::SignDecentralizedParty as mpc::Party>::Message: Send + Sync,
    {
        let access_structure =
            WeightedThresholdAccessStructure::new(threshold, party_to_weight.clone()).unwrap();

        let (protocol_public_parameters, decryption_key) = setup_class_groups_secp256r1();

        let secret_key_bits = protocol_public_parameters
            .encryption_scheme_public_parameters
            .randomness_space_public_parameters()
            .sample_bits;

        let base = protocol_public_parameters
            .encryption_scheme_public_parameters
            .setup_parameters
            .h;

        let (decryption_key_share_public_parameters, decryption_key_shares) =
            ::class_groups::test_helpers::deal_trusted_shares::<
                { U256::LIMBS },
                { crate::secp256r1::class_groups::FUNDAMENTAL_DISCRIMINANT_LIMBS },
                { crate::secp256r1::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS },
                secp256r1::GroupElement,
            >(
                threshold,
                access_structure.number_of_virtual_parties(),
                protocol_public_parameters
                    .encryption_scheme_public_parameters
                    .clone(),
                decryption_key.decryption_key,
                base,
                secret_key_bits,
            );

        let (dkg_session_id, access_structure) =
            crate::dkg::tests::setup_session(threshold, party_to_weight);

        let party_to_virtual_parties = access_structure.party_to_virtual_parties();
        let tangible_party_id_to_virtual_party_id_to_decryption_key_share: HashMap<
            _,
            HashMap<_, _>,
        > = access_structure
            .party_to_virtual_parties()
            .keys()
            .map(|&tangible_party_id| {
                let virtual_parties = party_to_virtual_parties
                    .get(&tangible_party_id)
                    .cloned()
                    .unwrap();

                (
                    tangible_party_id,
                    decryption_key_shares
                        .clone()
                        .into_iter()
                        .filter(|(party_id, _)| virtual_parties.contains(party_id))
                        .collect(),
                )
            })
            .collect();

        dkg_presign_signs_internal::<
            { secp256r1::SCALAR_LIMBS },
            { secp256r1::SCALAR_LIMBS },
            secp256r1::GroupElement,
            Secp256r1EncryptionKey,
            P,
        >(
            dkg_session_id,
            access_structure,
            hash_type,
            decryption_key_share_public_parameters,
            tangible_party_id_to_virtual_party_id_to_decryption_key_share,
            message,
            verify_signature,
            protocol_public_parameters,
            is_trusted_dealer,
            description.to_string(),
        );
    }

    #[rstest]
    #[case(2, HashMap::from([(1, 1), (2, 1)]), false)]
    #[case(2, HashMap::from([(1, 1), (2, 1)]), true)]
    #[case(4, HashMap::from([(1, 2), (2, 1), (3, 3)]), false)]
    #[case(4, HashMap::from([(1, 2), (2, 1), (3, 3)]), true)]
    fn dkg_presign_signs_schnorr_async_class_groups_curve25519(
        #[case] threshold: PartyID,
        #[case] party_to_weight: HashMap<PartyID, Weight>,
        #[case] is_trusted_dealer: bool,
    ) {
        dkg_presign_signs_async_class_groups_curve25519_internal::<
            crate::curve25519::class_groups::EdDSAProtocol,
        >(
            threshold,
            party_to_weight,
            HashScheme::SHA512,
            is_trusted_dealer,
            MESSAGE.as_bytes(),
            verify_eddsa_signature,
            "Class Groups Asynchronous Schnorr Curve25519 (EdDSA)",
        )
    }


    pub(crate) fn dkg_presign_signs_async_class_groups_curve25519_internal<P>(
        threshold: PartyID,
        party_to_weight: HashMap<PartyID, Weight>,
        hash_type: HashScheme,
        is_trusted_dealer: bool,
        message: &[u8],
        verify_signature: fn(
            public_key: curve25519::GroupElement,
            signature: P::Signature,
            message: &[u8],
            hash_type: HashScheme,
        ) -> crate::Result<()>,
        description: &str,
    ) where
        P: Protocol<
            CentralizedPartySecretKeyShare = SecretKeyShare<group::Value<curve25519::Scalar>>,
            CentralizedPartyDKGOutput = dkg::centralized_party::VersionedOutput<
                { curve25519::SCALAR_LIMBS },
                group::Value<curve25519::GroupElement>,
            >,
            DecentralizedPartyDKGOutput = crate::dkg::decentralized_party::VersionedOutput<
                { curve25519::SCALAR_LIMBS },
                group::Value<curve25519::GroupElement>,
                class_groups::CiphertextSpaceValue<{ crate::curve25519::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS }>,
            >,
            DecentralizedPartyTargetedDKGOutput = crate::dkg::decentralized_party::Output<
                group::Value<curve25519::GroupElement>,
                class_groups::CiphertextSpaceValue<{ crate::curve25519::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS }>,
            >,
            ProtocolPublicParameters = crate::class_groups::ProtocolPublicParameters<
                { curve25519::SCALAR_LIMBS },
                { crate::curve25519::class_groups::FUNDAMENTAL_DISCRIMINANT_LIMBS },
                { crate::curve25519::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS },
                curve25519::GroupElement,
            >,
            DecryptionKeySharePublicParameters = class_groups::Curve25519DecryptionKeySharePublicParameters,
            DecryptionKeyShare = SecretKeyShareSizedInteger,
            PublicKeyShareAndProof = PublicKeyShareAndProof<
                group::Value<curve25519::GroupElement>,
                KnowledgeOfDiscreteLogUCProof<{ curve25519::SCALAR_LIMBS }, curve25519::GroupElement>,
            >,
            SecretKey = group::Value<curve25519::Scalar>,
        >,
        <<P as Protocol>::SignDecentralizedParty as mpc::Party>::Message: Send + Sync,
    {
        let access_structure =
            WeightedThresholdAccessStructure::new(threshold, party_to_weight.clone()).unwrap();

        let (protocol_public_parameters, decryption_key) = setup_class_groups_curve25519();

        let secret_key_bits = protocol_public_parameters
            .encryption_scheme_public_parameters
            .randomness_space_public_parameters()
            .sample_bits;

        let base = protocol_public_parameters
            .encryption_scheme_public_parameters
            .setup_parameters
            .h;

        let (decryption_key_share_public_parameters, decryption_key_shares) =
            ::class_groups::test_helpers::deal_trusted_shares::<
                { U256::LIMBS },
                { crate::curve25519::class_groups::FUNDAMENTAL_DISCRIMINANT_LIMBS },
                { crate::curve25519::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS },
                curve25519::GroupElement,
            >(
                threshold,
                access_structure.number_of_virtual_parties(),
                protocol_public_parameters
                    .encryption_scheme_public_parameters
                    .clone(),
                decryption_key.decryption_key,
                base,
                secret_key_bits,
            );

        let (dkg_session_id, access_structure) =
            crate::dkg::tests::setup_session(threshold, party_to_weight);

        let party_to_virtual_parties = access_structure.party_to_virtual_parties();
        let tangible_party_id_to_virtual_party_id_to_decryption_key_share: HashMap<
            _,
            HashMap<_, _>,
        > = access_structure
            .party_to_virtual_parties()
            .keys()
            .map(|&tangible_party_id| {
                let virtual_parties = party_to_virtual_parties
                    .get(&tangible_party_id)
                    .cloned()
                    .unwrap();

                (
                    tangible_party_id,
                    decryption_key_shares
                        .clone()
                        .into_iter()
                        .filter(|(party_id, _)| virtual_parties.contains(party_id))
                        .collect(),
                )
            })
            .collect();

        dkg_presign_signs_internal::<
            { curve25519::SCALAR_LIMBS },
            { curve25519::SCALAR_LIMBS },
            curve25519::GroupElement,
            Curve25519EncryptionKey,
            P,
        >(
            dkg_session_id,
            access_structure,
            hash_type,
            decryption_key_share_public_parameters,
            tangible_party_id_to_virtual_party_id_to_decryption_key_share,
            message,
            verify_signature,
            protocol_public_parameters,
            is_trusted_dealer,
            description.to_string(),
        );
    }

    #[rstest]
    #[case(2, HashMap::from([(1, 1), (2, 1)]), false)]
    #[case(2, HashMap::from([(1, 1), (2, 1)]), true)]
    #[case(4, HashMap::from([(1, 2), (2, 1), (3, 3)]), false)]
    #[case(4, HashMap::from([(1, 2), (2, 1), (3, 3)]), true)]
    fn dkg_presign_signs_schnorr_async_class_groups_ristretto(
        #[case] threshold: PartyID,
        #[case] party_to_weight: HashMap<PartyID, Weight>,
        #[case] is_trusted_dealer: bool,
    ) {
        dkg_presign_signs_async_class_groups_ristretto_internal::<
            crate::ristretto::class_groups::SchnorrkelSubstrateProtocol,
        >(
            threshold,
            party_to_weight,
            HashScheme::Merlin,
            is_trusted_dealer,
            MESSAGE.as_bytes(),
            verify_schnorrkel_signature,
            "Class Groups Asynchronous Schnorr Ristretto (Schnorrkel/sr25519)",
        )
    }


    pub(crate) fn dkg_presign_signs_async_class_groups_ristretto_internal<P>(
        threshold: PartyID,
        party_to_weight: HashMap<PartyID, Weight>,
        hash_type: HashScheme,
        is_trusted_dealer: bool,
        message: &[u8],
        verify_signature: fn(
            public_key: ristretto::GroupElement,
            signature: P::Signature,
            message: &[u8],
            hash_type: HashScheme,
        ) -> crate::Result<()>,
        description: &str,
    ) where
        P: Protocol<
            CentralizedPartySecretKeyShare = SecretKeyShare<group::Value<ristretto::Scalar>>,
            CentralizedPartyDKGOutput = dkg::centralized_party::VersionedOutput<
                { ristretto::SCALAR_LIMBS },
                group::Value<ristretto::GroupElement>,
            >,
            DecentralizedPartyDKGOutput = crate::dkg::decentralized_party::VersionedOutput<
                { ristretto::SCALAR_LIMBS },
                group::Value<ristretto::GroupElement>,
                class_groups::CiphertextSpaceValue<{ crate::ristretto::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS }>,
            >,
            DecentralizedPartyTargetedDKGOutput = crate::dkg::decentralized_party::Output<
                group::Value<ristretto::GroupElement>,
                class_groups::CiphertextSpaceValue<{ crate::ristretto::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS }>,
            >,
            ProtocolPublicParameters = crate::class_groups::ProtocolPublicParameters<
                { ristretto::SCALAR_LIMBS },
                { crate::ristretto::class_groups::FUNDAMENTAL_DISCRIMINANT_LIMBS },
                { crate::ristretto::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS },
                ristretto::GroupElement,
            >,
            DecryptionKeySharePublicParameters = class_groups::RistrettoDecryptionKeySharePublicParameters,
            DecryptionKeyShare = SecretKeyShareSizedInteger,
            PublicKeyShareAndProof = PublicKeyShareAndProof<
                group::Value<ristretto::GroupElement>,
                KnowledgeOfDiscreteLogUCProof<{ ristretto::SCALAR_LIMBS }, ristretto::GroupElement>,
            >,
            SecretKey = group::Value<ristretto::Scalar>,
        >,
        <<P as Protocol>::SignDecentralizedParty as mpc::Party>::Message: Send + Sync,
    {
        let access_structure =
            WeightedThresholdAccessStructure::new(threshold, party_to_weight.clone()).unwrap();

        let (protocol_public_parameters, decryption_key) = setup_class_groups_ristretto();

        let secret_key_bits = protocol_public_parameters
            .encryption_scheme_public_parameters
            .randomness_space_public_parameters()
            .sample_bits;

        let base = protocol_public_parameters
            .encryption_scheme_public_parameters
            .setup_parameters
            .h;

        let (decryption_key_share_public_parameters, decryption_key_shares) =
            ::class_groups::test_helpers::deal_trusted_shares::<
                { U256::LIMBS },
                { crate::ristretto::class_groups::FUNDAMENTAL_DISCRIMINANT_LIMBS },
                { crate::ristretto::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS },
                ristretto::GroupElement,
            >(
                threshold,
                access_structure.number_of_virtual_parties(),
                protocol_public_parameters
                    .encryption_scheme_public_parameters
                    .clone(),
                decryption_key.decryption_key,
                base,
                secret_key_bits,
            );

        let (dkg_session_id, access_structure) =
            crate::dkg::tests::setup_session(threshold, party_to_weight);

        let party_to_virtual_parties = access_structure.party_to_virtual_parties();
        let tangible_party_id_to_virtual_party_id_to_decryption_key_share: HashMap<
            _,
            HashMap<_, _>,
        > = access_structure
            .party_to_virtual_parties()
            .keys()
            .map(|&tangible_party_id| {
                let virtual_parties = party_to_virtual_parties
                    .get(&tangible_party_id)
                    .cloned()
                    .unwrap();

                (
                    tangible_party_id,
                    decryption_key_shares
                        .clone()
                        .into_iter()
                        .filter(|(party_id, _)| virtual_parties.contains(party_id))
                        .collect(),
                )
            })
            .collect();

        dkg_presign_signs_internal::<
            { ristretto::SCALAR_LIMBS },
            { ristretto::SCALAR_LIMBS },
            ristretto::GroupElement,
            RistrettoEncryptionKey,
            P,
        >(
            dkg_session_id,
            access_structure,
            hash_type,
            decryption_key_share_public_parameters,
            tangible_party_id_to_virtual_party_id_to_decryption_key_share,
            message,
            verify_signature,
            protocol_public_parameters,
            is_trusted_dealer,
            description.to_string(),
        );
    }

    #[rstest]
    #[case(2, HashMap::from([(1, 1), (2, 1)]), false, HashScheme::SHA256)]
    #[case(2, HashMap::from([(1, 1), (2, 1)]), true, HashScheme::SHA256)]
    #[case(4, HashMap::from([(1, 2), (2, 1), (3, 3)]), false, HashScheme::SHA256)]
    #[case(4, HashMap::from([(1, 2), (2, 1), (3, 3)]), true, HashScheme::SHA256)]
    fn dkg_presign_signs_ecdsa_async_class_groups_secp256k1(
        #[case] threshold: PartyID,
        #[case] party_to_weight: HashMap<PartyID, Weight>,
        #[case] is_trusted_dealer: bool,
        #[case] hash_type: HashScheme,
    ) {
        dkg_presign_signs_async_class_groups_secp256k1_internal::<
            crate::secp256k1::class_groups::ECDSAProtocol,
        >(
            threshold,
            party_to_weight,
            hash_type,
            is_trusted_dealer,
            MESSAGE.as_bytes(),
            verify_secp256k1_ecdsa_signature,
            "Class Groups Asynchronous ECDSA secp256k1",
        )
    }

    #[rstest]
    #[case(2, HashMap::from([(1, 1), (2, 1)]), false)]
    #[case(2, HashMap::from([(1, 1), (2, 1)]), true)]
    #[case(4, HashMap::from([(1, 2), (2, 1), (3, 3)]), false)]
    #[case(4, HashMap::from([(1, 2), (2, 1), (3, 3)]), true)]
    fn dkg_presign_signs_schnorr_async_class_groups_secp256k1(
        #[case] threshold: PartyID,
        #[case] party_to_weight: HashMap<PartyID, Weight>,
        #[case] is_trusted_dealer: bool,
    ) {
        let hashed_message = k256::sha2::Sha256::new_with_prefix(MESSAGE).finalize();

        dkg_presign_signs_async_class_groups_secp256k1_internal::<
            crate::secp256k1::class_groups::TaprootProtocol,
        >(
            threshold,
            party_to_weight,
            HashScheme::SHA256,
            is_trusted_dealer,
            &hashed_message,
            verify_taproot_signature,
            "Class Groups Asynchronous Schnorr secp256k1 (Taproot)",
        )
    }


    pub(crate) fn dkg_presign_signs_async_class_groups_secp256k1_internal<P>(
        threshold: PartyID,
        party_to_weight: HashMap<PartyID, Weight>,
        hash_type: HashScheme,
        is_trusted_dealer: bool,
        message: &[u8],
        verify_signature: fn(
            public_key: secp256k1::GroupElement,
            signature: P::Signature,
            message: &[u8],
            hash_type: HashScheme,
        ) -> crate::Result<()>,
        description: &str,
    ) where
        P: Protocol<
            CentralizedPartySecretKeyShare = SecretKeyShare<group::Value<secp256k1::Scalar>>,
            CentralizedPartyDKGOutput = dkg::centralized_party::VersionedOutput<
                { secp256k1::SCALAR_LIMBS },
                group::Value<secp256k1::GroupElement>,
            >,
            DecentralizedPartyDKGOutput = crate::dkg::decentralized_party::VersionedOutput<
                { secp256k1::SCALAR_LIMBS },
                group::Value<secp256k1::GroupElement>,
                class_groups::CiphertextSpaceValue<{ crate::secp256k1::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS }>,
            >,
            DecentralizedPartyTargetedDKGOutput = crate::dkg::decentralized_party::Output<
                group::Value<secp256k1::GroupElement>,
                class_groups::CiphertextSpaceValue<{ crate::secp256k1::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS }>,
            >,
            ProtocolPublicParameters = crate::class_groups::ProtocolPublicParameters<
                { secp256k1::SCALAR_LIMBS },
                { crate::secp256k1::class_groups::FUNDAMENTAL_DISCRIMINANT_LIMBS },
                { crate::secp256k1::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS },
                secp256k1::GroupElement,
            >,
            DecryptionKeySharePublicParameters = class_groups::Secp256k1DecryptionKeySharePublicParameters,
            DecryptionKeyShare = SecretKeyShareSizedInteger,
            PublicKeyShareAndProof = PublicKeyShareAndProof<
                group::Value<secp256k1::GroupElement>,
                KnowledgeOfDiscreteLogUCProof<{ secp256k1::SCALAR_LIMBS }, secp256k1::GroupElement>,
            >,
            SecretKey = group::Value<secp256k1::Scalar>,
        >,
        <<P as Protocol>::SignDecentralizedParty as mpc::Party>::Message: Send + Sync,
    {
        let access_structure =
            WeightedThresholdAccessStructure::new(threshold, party_to_weight.clone()).unwrap();

        let (protocol_public_parameters, decryption_key) = setup_class_groups_secp256k1();

        let secret_key_bits = protocol_public_parameters
            .encryption_scheme_public_parameters
            .randomness_space_public_parameters()
            .sample_bits;

        let base = protocol_public_parameters
            .encryption_scheme_public_parameters
            .setup_parameters
            .h;

        let (decryption_key_share_public_parameters, decryption_key_shares) =
            ::class_groups::test_helpers::deal_trusted_shares::<
                { U256::LIMBS },
                { crate::secp256k1::class_groups::FUNDAMENTAL_DISCRIMINANT_LIMBS },
                { crate::secp256k1::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS },
                secp256k1::GroupElement,
            >(
                threshold,
                access_structure.number_of_virtual_parties(),
                protocol_public_parameters
                    .encryption_scheme_public_parameters
                    .clone(),
                decryption_key.decryption_key,
                base,
                secret_key_bits,
            );

        let (dkg_session_id, access_structure) =
            crate::dkg::tests::setup_session(threshold, party_to_weight);

        let party_to_virtual_parties = access_structure.party_to_virtual_parties();
        let tangible_party_id_to_virtual_party_id_to_decryption_key_share: HashMap<
            _,
            HashMap<_, _>,
        > = access_structure
            .party_to_virtual_parties()
            .keys()
            .map(|&tangible_party_id| {
                let virtual_parties = party_to_virtual_parties
                    .get(&tangible_party_id)
                    .cloned()
                    .unwrap();

                (
                    tangible_party_id,
                    decryption_key_shares
                        .clone()
                        .into_iter()
                        .filter(|(party_id, _)| virtual_parties.contains(party_id))
                        .collect(),
                )
            })
            .collect();

        dkg_presign_signs_internal::<
            { secp256k1::SCALAR_LIMBS },
            { secp256k1::SCALAR_LIMBS },
            secp256k1::GroupElement,
            Secp256k1EncryptionKey,
            P,
        >(
            dkg_session_id,
            access_structure,
            hash_type,
            decryption_key_share_public_parameters,
            tangible_party_id_to_virtual_party_id_to_decryption_key_share,
            message,
            verify_signature,
            protocol_public_parameters,
            is_trusted_dealer,
            description.to_string(),
        );
    }

    #[rstest]
    #[case(2, HashMap::from([(1, 1), (2, 1)]))]
    #[case(4, HashMap::from([(1, 2), (2, 1), (3, 3)]))]
    fn signs_async_ecdsa_class_groups_secp256r1(
        #[case] threshold: PartyID,
        #[case] party_to_weight: HashMap<PartyID, Weight>,
    ) {
        signs_async_class_groups_secp256r1_internal::<crate::secp256r1::class_groups::ECDSAProtocol>(
            threshold,
            party_to_weight,
            HashScheme::SHA256,
            HashSet::new(),
            false,
            true,
            MESSAGE.as_bytes(),
            verify_secp256r1_ecdsa_signature,
            "Class Groups Asynchronous ECDSA secp256r1",
        )
    }


    pub(crate) fn signs_async_class_groups_secp256r1_internal<P>(
        threshold: PartyID,
        party_to_weight: HashMap<PartyID, Weight>,
        hash_type: HashScheme,
        malicious_parties: HashSet<PartyID>,
        bench: bool,
        expected_case: bool,
        message: &[u8],
        verify_signature: fn(
            public_key: secp256r1::GroupElement,
            signature: P::Signature,
            message: &[u8],
            hash_type: HashScheme,
        ) -> crate::Result<()>,
        description: &str,
    ) where
        P: Protocol<
            CentralizedPartySecretKeyShare = SecretKeyShare<group::Value<secp256r1::Scalar>>,
            CentralizedPartyDKGOutput = dkg::centralized_party::VersionedOutput<
                { secp256r1::SCALAR_LIMBS },
                group::Value<secp256r1::GroupElement>,
            >,
            DecentralizedPartyDKGOutput = crate::dkg::decentralized_party::VersionedOutput<
                { secp256r1::SCALAR_LIMBS },
                group::Value<secp256r1::GroupElement>,
                class_groups::CiphertextSpaceValue<{ crate::secp256r1::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS }>,
            >,
            ProtocolPublicParameters = crate::class_groups::ProtocolPublicParameters<
                { secp256r1::SCALAR_LIMBS },
                { crate::secp256r1::class_groups::FUNDAMENTAL_DISCRIMINANT_LIMBS },
                { crate::secp256r1::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS },
                secp256r1::GroupElement,
            >,
            PublicKeyShareAndProof = PublicKeyShareAndProof<
                group::Value<secp256r1::GroupElement>,
                KnowledgeOfDiscreteLogUCProof<{ secp256r1::SCALAR_LIMBS }, secp256r1::GroupElement>,
            >,
            DecryptionKeySharePublicParameters = class_groups::Secp256r1DecryptionKeySharePublicParameters,
            DecryptionKeyShare = SecretKeyShareSizedInteger,
            SecretKey = group::Value<secp256r1::Scalar>,
        > + MockablePresignProtocol,
        <<P as Protocol>::SignDecentralizedParty as mpc::Party>::Message: Send + Sync,
    {
        let access_structure =
            WeightedThresholdAccessStructure::new(threshold, party_to_weight.clone()).unwrap();

        let (protocol_public_parameters, decryption_key) = setup_class_groups_secp256r1();

        let secret_key_bits = protocol_public_parameters
            .encryption_scheme_public_parameters
            .randomness_space_public_parameters()
            .sample_bits;

        let base = protocol_public_parameters
            .encryption_scheme_public_parameters
            .setup_parameters
            .h;

        let (decryption_key_share_public_parameters, decryption_key_shares) =
            ::class_groups::test_helpers::deal_trusted_shares::<
                { U256::LIMBS },
                { crate::secp256r1::class_groups::FUNDAMENTAL_DISCRIMINANT_LIMBS },
                { crate::secp256r1::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS },
                secp256r1::GroupElement,
            >(
                threshold,
                access_structure.number_of_virtual_parties(),
                protocol_public_parameters
                    .encryption_scheme_public_parameters
                    .clone(),
                decryption_key.decryption_key,
                base,
                secret_key_bits,
            );

        let decryption_key_shares: Vec<_> = decryption_key_shares
            .into_iter()
            .map(|(virtual_party_id, decryption_key_share)| {
                let decryption_key_share = if malicious_parties.contains(
                    &access_structure
                        .to_tangible_party_id(virtual_party_id)
                        .unwrap(),
                ) {
                    let wrong_share = Uint::random(&mut OsCsRng);
                    let wrong_share = wrong_share
                        & (Uint::ONE
                            << secret_key_share_size_upper_bound(
                                u32::from(access_structure.number_of_virtual_parties()),
                                u32::from(access_structure.threshold),
                                secret_key_bits,
                            ));

                    Int::new_from_abs_sign(
                        wrong_share,
                        ConstChoice::from(Choice::from(u8::from(virtual_party_id % 2 == 0))),
                    )
                    .unwrap()
                } else {
                    decryption_key_share
                };

                (virtual_party_id, decryption_key_share)
            })
            .collect();

        let access_structure =
            WeightedThresholdAccessStructure::new(threshold, party_to_weight).unwrap();

        let party_to_virtual_parties = access_structure.party_to_virtual_parties();
        let tangible_party_id_to_virtual_party_id_to_decryption_key_share: HashMap<
            _,
            HashMap<_, _>,
        > = party_to_virtual_parties
            .keys()
            .map(|&tangible_party_id| {
                let virtual_parties = party_to_virtual_parties
                    .get(&tangible_party_id)
                    .cloned()
                    .unwrap();
                (
                    tangible_party_id,
                    decryption_key_shares
                        .clone()
                        .into_iter()
                        .filter(|(party_id, _)| virtual_parties.contains(party_id))
                        .collect(),
                )
            })
            .collect();

        let (
            centralized_party_dkg_output,
            centralized_party_secret_key_share,
            decentralized_party_dkg_output,
        ) = mock_targeted_dkg_output::<
            { secp256r1::SCALAR_LIMBS },
            { secp256r1::SCALAR_LIMBS },
            secp256r1::GroupElement,
            Secp256r1EncryptionKey,
        >(&protocol_public_parameters);

        let presign_session_id = CommitmentSizedNumber::random(&mut OsCsRng);

        let presign = P::mock_presign(
            presign_session_id,
            decentralized_party_dkg_output.clone(),
            &protocol_public_parameters,
        );

        signs_internal_generic::<
            { secp256r1::SCALAR_LIMBS },
            { secp256r1::SCALAR_LIMBS },
            secp256r1::GroupElement,
            Secp256r1EncryptionKey,
            P,
        >(
            presign_session_id,
            access_structure,
            hash_type,
            centralized_party_secret_key_share,
            centralized_party_dkg_output,
            decentralized_party_dkg_output,
            presign,
            decryption_key_share_public_parameters,
            tangible_party_id_to_virtual_party_id_to_decryption_key_share,
            message,
            verify_signature,
            protocol_public_parameters,
            description.to_string(),
            malicious_parties,
            bench,
            expected_case,
        );
    }

    #[rstest]
    #[case(2, HashMap::from([(1, 1), (2, 1)]))]
    #[case(4, HashMap::from([(1, 2), (2, 1), (3, 3)]))]
    fn signs_async_schnorr_class_groups_curve25519(
        #[case] threshold: PartyID,
        #[case] party_to_weight: HashMap<PartyID, Weight>,
    ) {
        signs_async_class_groups_curve25519_internal::<crate::curve25519::class_groups::EdDSAProtocol>(
            threshold,
            party_to_weight,
            HashScheme::SHA512,
            HashSet::new(),
            false,
            true,
            MESSAGE.as_bytes(),
            verify_eddsa_signature,
            "Class Groups Asynchronous Schnorr Curve25519 (EdDSA)",
        )
    }


    pub(crate) fn signs_async_class_groups_curve25519_internal<P>(
        threshold: PartyID,
        party_to_weight: HashMap<PartyID, Weight>,
        hash_type: HashScheme,
        malicious_parties: HashSet<PartyID>,
        bench: bool,
        expected_case: bool,
        message: &[u8],
        verify_signature: fn(
            public_key: curve25519::GroupElement,
            signature: P::Signature,
            message: &[u8],
            hash_type: HashScheme,
        ) -> crate::Result<()>,
        description: &str,
    ) where
        P: Protocol<
            CentralizedPartySecretKeyShare = SecretKeyShare<group::Value<curve25519::Scalar>>,
            CentralizedPartyDKGOutput = dkg::centralized_party::VersionedOutput<
                { curve25519::SCALAR_LIMBS },
                group::Value<curve25519::GroupElement>,
            >,
            DecentralizedPartyDKGOutput = crate::dkg::decentralized_party::VersionedOutput<
                { curve25519::SCALAR_LIMBS },
                group::Value<curve25519::GroupElement>,
                class_groups::CiphertextSpaceValue<{ crate::curve25519::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS }>,
            >,
            ProtocolPublicParameters = crate::class_groups::ProtocolPublicParameters<
                { curve25519::SCALAR_LIMBS },
                { crate::curve25519::class_groups::FUNDAMENTAL_DISCRIMINANT_LIMBS },
                { crate::curve25519::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS },
                curve25519::GroupElement,
            >,
            PublicKeyShareAndProof = PublicKeyShareAndProof<
                group::Value<curve25519::GroupElement>,
                KnowledgeOfDiscreteLogUCProof<{ curve25519::SCALAR_LIMBS }, curve25519::GroupElement>,
            >,
            DecryptionKeySharePublicParameters = class_groups::Curve25519DecryptionKeySharePublicParameters,
            DecryptionKeyShare = SecretKeyShareSizedInteger,
            SecretKey = group::Value<curve25519::Scalar>,
        > + MockablePresignProtocol,
        <<P as Protocol>::SignDecentralizedParty as mpc::Party>::Message: Send + Sync,
    {
        let access_structure =
            WeightedThresholdAccessStructure::new(threshold, party_to_weight.clone()).unwrap();

        let (protocol_public_parameters, decryption_key) = setup_class_groups_curve25519();

        let secret_key_bits = protocol_public_parameters
            .encryption_scheme_public_parameters
            .randomness_space_public_parameters()
            .sample_bits;

        let base = protocol_public_parameters
            .encryption_scheme_public_parameters
            .setup_parameters
            .h;

        let (decryption_key_share_public_parameters, decryption_key_shares) =
            ::class_groups::test_helpers::deal_trusted_shares::<
                { U256::LIMBS },
                { crate::curve25519::class_groups::FUNDAMENTAL_DISCRIMINANT_LIMBS },
                { crate::curve25519::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS },
                curve25519::GroupElement,
            >(
                threshold,
                access_structure.number_of_virtual_parties(),
                protocol_public_parameters
                    .encryption_scheme_public_parameters
                    .clone(),
                decryption_key.decryption_key,
                base,
                secret_key_bits,
            );

        let decryption_key_shares: Vec<_> = decryption_key_shares
            .into_iter()
            .map(|(virtual_party_id, decryption_key_share)| {
                let decryption_key_share = if malicious_parties.contains(
                    &access_structure
                        .to_tangible_party_id(virtual_party_id)
                        .unwrap(),
                ) {
                    let wrong_share = Uint::random(&mut OsCsRng);
                    let wrong_share = wrong_share
                        & (Uint::ONE
                            << secret_key_share_size_upper_bound(
                                u32::from(access_structure.number_of_virtual_parties()),
                                u32::from(access_structure.threshold),
                                secret_key_bits,
                            ));

                    Int::new_from_abs_sign(
                        wrong_share,
                        ConstChoice::from(Choice::from(u8::from(virtual_party_id % 2 == 0))),
                    )
                    .unwrap()
                } else {
                    decryption_key_share
                };

                (virtual_party_id, decryption_key_share)
            })
            .collect();

        let access_structure =
            WeightedThresholdAccessStructure::new(threshold, party_to_weight).unwrap();

        let party_to_virtual_parties = access_structure.party_to_virtual_parties();
        let tangible_party_id_to_virtual_party_id_to_decryption_key_share: HashMap<
            _,
            HashMap<_, _>,
        > = party_to_virtual_parties
            .keys()
            .map(|&tangible_party_id| {
                let virtual_parties = party_to_virtual_parties
                    .get(&tangible_party_id)
                    .cloned()
                    .unwrap();
                (
                    tangible_party_id,
                    decryption_key_shares
                        .clone()
                        .into_iter()
                        .filter(|(party_id, _)| virtual_parties.contains(party_id))
                        .collect(),
                )
            })
            .collect();

        let (
            centralized_party_dkg_output,
            centralized_party_secret_key_share,
            decentralized_party_dkg_output,
        ) = mock_targeted_dkg_output::<
            { curve25519::SCALAR_LIMBS },
            { curve25519::SCALAR_LIMBS },
            curve25519::GroupElement,
            Curve25519EncryptionKey,
        >(&protocol_public_parameters);

        let presign_session_id = CommitmentSizedNumber::random(&mut OsCsRng);

        let presign = P::mock_presign(
            presign_session_id,
            decentralized_party_dkg_output.clone(),
            &protocol_public_parameters,
        );

        signs_internal_generic::<
            { curve25519::SCALAR_LIMBS },
            { curve25519::SCALAR_LIMBS },
            curve25519::GroupElement,
            Curve25519EncryptionKey,
            P,
        >(
            presign_session_id,
            access_structure,
            hash_type,
            centralized_party_secret_key_share,
            centralized_party_dkg_output,
            decentralized_party_dkg_output,
            presign,
            decryption_key_share_public_parameters,
            tangible_party_id_to_virtual_party_id_to_decryption_key_share,
            message,
            verify_signature,
            protocol_public_parameters,
            description.to_string(),
            malicious_parties,
            bench,
            expected_case,
        );
    }

    #[rstest]
    #[case(2, HashMap::from([(1, 1), (2, 1)]))]
    #[case(4, HashMap::from([(1, 2), (2, 1), (3, 3)]))]
    fn signs_async_schnorr_class_groups_ristretto(
        #[case] threshold: PartyID,
        #[case] party_to_weight: HashMap<PartyID, Weight>,
    ) {
        signs_async_class_groups_ristretto_internal::<
            crate::ristretto::class_groups::SchnorrkelSubstrateProtocol,
        >(
            threshold,
            party_to_weight,
            HashScheme::Merlin,
            HashSet::new(),
            false,
            true,
            MESSAGE.as_bytes(),
            verify_schnorrkel_signature,
            "Class Groups Asynchronous Schnorr Ristretto (Schnorrkel/sr25519)",
        )
    }


    pub(crate) fn signs_async_class_groups_ristretto_internal<P>(
        threshold: PartyID,
        party_to_weight: HashMap<PartyID, Weight>,
        hash_type: HashScheme,
        malicious_parties: HashSet<PartyID>,
        bench: bool,
        expected_case: bool,
        message: &[u8],
        verify_signature: fn(
            public_key: ristretto::GroupElement,
            signature: P::Signature,
            message: &[u8],
            hash_type: HashScheme,
        ) -> crate::Result<()>,
        description: &str,
    ) where
        P: Protocol<
            CentralizedPartySecretKeyShare = SecretKeyShare<group::Value<ristretto::Scalar>>,
            CentralizedPartyDKGOutput = dkg::centralized_party::VersionedOutput<
                { ristretto::SCALAR_LIMBS },
                group::Value<ristretto::GroupElement>,
            >,
            DecentralizedPartyDKGOutput = crate::dkg::decentralized_party::VersionedOutput<
                { ristretto::SCALAR_LIMBS },
                group::Value<ristretto::GroupElement>,
                class_groups::CiphertextSpaceValue<{ crate::ristretto::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS }>,
            >,
            ProtocolPublicParameters = crate::class_groups::ProtocolPublicParameters<
                { ristretto::SCALAR_LIMBS },
                { crate::ristretto::class_groups::FUNDAMENTAL_DISCRIMINANT_LIMBS },
                { crate::ristretto::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS },
                ristretto::GroupElement,
            >,
            PublicKeyShareAndProof = PublicKeyShareAndProof<
                group::Value<ristretto::GroupElement>,
                KnowledgeOfDiscreteLogUCProof<{ ristretto::SCALAR_LIMBS }, ristretto::GroupElement>,
            >,
            DecryptionKeySharePublicParameters = class_groups::RistrettoDecryptionKeySharePublicParameters,
            DecryptionKeyShare = SecretKeyShareSizedInteger,
            SecretKey = group::Value<ristretto::Scalar>,
        > + MockablePresignProtocol,
        <<P as Protocol>::SignDecentralizedParty as mpc::Party>::Message: Send + Sync,
    {
        let access_structure =
            WeightedThresholdAccessStructure::new(threshold, party_to_weight.clone()).unwrap();

        let (protocol_public_parameters, decryption_key) = setup_class_groups_ristretto();

        let secret_key_bits = protocol_public_parameters
            .encryption_scheme_public_parameters
            .randomness_space_public_parameters()
            .sample_bits;

        let base = protocol_public_parameters
            .encryption_scheme_public_parameters
            .setup_parameters
            .h;

        let (decryption_key_share_public_parameters, decryption_key_shares) =
            ::class_groups::test_helpers::deal_trusted_shares::<
                { U256::LIMBS },
                { crate::ristretto::class_groups::FUNDAMENTAL_DISCRIMINANT_LIMBS },
                { crate::ristretto::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS },
                ristretto::GroupElement,
            >(
                threshold,
                access_structure.number_of_virtual_parties(),
                protocol_public_parameters
                    .encryption_scheme_public_parameters
                    .clone(),
                decryption_key.decryption_key,
                base,
                secret_key_bits,
            );

        let decryption_key_shares: Vec<_> = decryption_key_shares
            .into_iter()
            .map(|(virtual_party_id, decryption_key_share)| {
                let decryption_key_share = if malicious_parties.contains(
                    &access_structure
                        .to_tangible_party_id(virtual_party_id)
                        .unwrap(),
                ) {
                    let wrong_share = Uint::random(&mut OsCsRng);
                    let wrong_share = wrong_share
                        & (Uint::ONE
                            << secret_key_share_size_upper_bound(
                                u32::from(access_structure.number_of_virtual_parties()),
                                u32::from(access_structure.threshold),
                                secret_key_bits,
                            ));

                    Int::new_from_abs_sign(
                        wrong_share,
                        ConstChoice::from(Choice::from(u8::from(virtual_party_id % 2 == 0))),
                    )
                    .unwrap()
                } else {
                    decryption_key_share
                };

                (virtual_party_id, decryption_key_share)
            })
            .collect();

        let access_structure =
            WeightedThresholdAccessStructure::new(threshold, party_to_weight).unwrap();

        let party_to_virtual_parties = access_structure.party_to_virtual_parties();
        let tangible_party_id_to_virtual_party_id_to_decryption_key_share: HashMap<
            _,
            HashMap<_, _>,
        > = party_to_virtual_parties
            .keys()
            .map(|&tangible_party_id| {
                let virtual_parties = party_to_virtual_parties
                    .get(&tangible_party_id)
                    .cloned()
                    .unwrap();
                (
                    tangible_party_id,
                    decryption_key_shares
                        .clone()
                        .into_iter()
                        .filter(|(party_id, _)| virtual_parties.contains(party_id))
                        .collect(),
                )
            })
            .collect();

        let (
            centralized_party_dkg_output,
            centralized_party_secret_key_share,
            decentralized_party_dkg_output,
        ) = mock_targeted_dkg_output::<
            { ristretto::SCALAR_LIMBS },
            { ristretto::SCALAR_LIMBS },
            ristretto::GroupElement,
            RistrettoEncryptionKey,
        >(&protocol_public_parameters);

        let presign_session_id = CommitmentSizedNumber::random(&mut OsCsRng);

        let presign = P::mock_presign(
            presign_session_id,
            decentralized_party_dkg_output.clone(),
            &protocol_public_parameters,
        );

        signs_internal_generic::<
            { ristretto::SCALAR_LIMBS },
            { ristretto::SCALAR_LIMBS },
            ristretto::GroupElement,
            RistrettoEncryptionKey,
            P,
        >(
            presign_session_id,
            access_structure,
            hash_type,
            centralized_party_secret_key_share,
            centralized_party_dkg_output,
            decentralized_party_dkg_output,
            presign,
            decryption_key_share_public_parameters,
            tangible_party_id_to_virtual_party_id_to_decryption_key_share,
            message,
            verify_signature,
            protocol_public_parameters,
            description.to_string(),
            malicious_parties,
            bench,
            expected_case,
        );
    }

    #[rstest]
    #[case(2, HashMap::from([(1, 1), (2, 1)]))]
    #[case(4, HashMap::from([(1, 2), (2, 1), (3, 3)]))]
    fn signs_async_schnorr_class_groups_secp256k1(
        #[case] threshold: PartyID,
        #[case] party_to_weight: HashMap<PartyID, Weight>,
    ) {
        let hashed_message = k256::sha2::Sha256::new_with_prefix(MESSAGE).finalize();

        signs_async_class_groups_secp256k1_internal::<crate::secp256k1::class_groups::TaprootProtocol>(
            threshold,
            party_to_weight,
            HashScheme::SHA256,
            HashSet::new(),
            false,
            true,
            &hashed_message,
            verify_taproot_signature,
            "Class Groups Asynchronous Schnorr secp256k1 (Taproot)",
        )
    }

    #[rstest]
    #[case(2, HashMap::from([(1, 1), (2, 1)]), HashScheme::SHA256)]
    #[case(2, HashMap::from([(1, 1), (2, 1)]), HashScheme::DoubleSHA256)]
    #[case(2, HashMap::from([(1, 1), (2, 1)]), HashScheme::Keccak256)]
    #[case(4, HashMap::from([(1, 2), (2, 1), (3, 3)]), HashScheme::SHA256)]
    #[case(4, HashMap::from([(1, 2), (2, 1), (3, 3)]), HashScheme::Keccak256)]
    #[case(4, HashMap::from([(1, 2), (2, 1), (3, 3)]), HashScheme::DoubleSHA256)]
    fn signs_async_ecdsa_class_groups_secp256k1(
        #[case] threshold: PartyID,
        #[case] party_to_weight: HashMap<PartyID, Weight>,
        #[case] hash_type: HashScheme,
    ) {
        signs_async_class_groups_secp256k1_internal::<crate::secp256k1::class_groups::ECDSAProtocol>(
            threshold,
            party_to_weight,
            hash_type,
            HashSet::new(),
            false,
            true,
            MESSAGE.as_bytes(),
            verify_secp256k1_ecdsa_signature,
            "Class Groups Asynchronous ECDSA secp256k1",
        )
    }

    #[rstest]
    #[case(3, HashMap::from([(1, 1), (2, 2), (3, 2)]), HashSet::from([1]))]
    #[case(4, HashMap::from([(1, 2), (2, 2), (3, 2)]), HashSet::from([1]))]
    #[case(6, HashMap::from([(1, 1), (2, 2), (3, 3), (4, 1), (5, 3)]), HashSet::from([2, 4]))]
    #[case(10, HashMap::from([(1, 1), (2, 2), (3, 3), (4, 1), (5, 3), (6,6), (7, 1), (8, 1), (9, 1), (10, 1), (11, 3)]), HashSet::from([5, 7]))]
    fn signs_async_with_malicious_class_groups_secp256k1(
        #[case] threshold: PartyID,
        #[case] party_to_weight: HashMap<PartyID, Weight>,
        #[case] malicious_parties: HashSet<PartyID>,
    ) {
        signs_async_class_groups_secp256k1_internal::<crate::secp256k1::class_groups::ECDSAProtocol>(
            threshold,
            party_to_weight,
            HashScheme::SHA256,
            malicious_parties,
            false,
            true,
            MESSAGE.as_bytes(),
            verify_secp256k1_ecdsa_signature,
            "Class Groups Asynchronous ECDSA secp256k1",
        );
    }

    #[rstest]
    #[case(8, HashMap::from([(1, 1), (2, 2), (3, 3), (4, 1), (5, 3), (6,6), (7, 1), (8, 1)]), HashSet::from([5, 7]))]
    fn signs_async_unexpected_with_malicious_class_groups_secp256k1(
        #[case] threshold: PartyID,
        #[case] party_to_weight: HashMap<PartyID, Weight>,
        #[case] malicious_parties: HashSet<PartyID>,
    ) {
        signs_async_class_groups_secp256k1_internal::<crate::secp256k1::class_groups::ECDSAProtocol>(
            threshold,
            party_to_weight,
            HashScheme::SHA256,
            malicious_parties,
            false,
            false,
            MESSAGE.as_bytes(),
            verify_secp256k1_ecdsa_signature,
            "Class Groups Asynchronous ECDSA secp256k1",
        );
    }


    pub(crate) fn signs_async_class_groups_secp256k1_internal<P>(
        threshold: PartyID,
        party_to_weight: HashMap<PartyID, Weight>,
        hash_type: HashScheme,
        malicious_parties: HashSet<PartyID>,
        bench: bool,
        expected_case: bool,
        message: &[u8],
        verify_signature: fn(
            public_key: secp256k1::GroupElement,
            signature: P::Signature,
            message: &[u8],
            hash_type: HashScheme,
        ) -> crate::Result<()>,
        description: &str,
    ) where
        P: Protocol<
            CentralizedPartySecretKeyShare = SecretKeyShare<group::Value<secp256k1::Scalar>>,
            CentralizedPartyDKGOutput = dkg::centralized_party::VersionedOutput<
                { secp256k1::SCALAR_LIMBS },
                group::Value<secp256k1::GroupElement>,
            >,
            DecentralizedPartyDKGOutput = crate::dkg::decentralized_party::VersionedOutput<
                { secp256k1::SCALAR_LIMBS },
                group::Value<secp256k1::GroupElement>,
                class_groups::CiphertextSpaceValue<{ crate::secp256k1::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS }>,
            >,
            ProtocolPublicParameters = crate::class_groups::ProtocolPublicParameters<
                { secp256k1::SCALAR_LIMBS },
                { crate::secp256k1::class_groups::FUNDAMENTAL_DISCRIMINANT_LIMBS },
                { crate::secp256k1::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS },
                secp256k1::GroupElement,
            >,
            PublicKeyShareAndProof = PublicKeyShareAndProof<
                group::Value<secp256k1::GroupElement>,
                KnowledgeOfDiscreteLogUCProof<{ secp256k1::SCALAR_LIMBS }, secp256k1::GroupElement>,
            >,
            DecryptionKeySharePublicParameters = class_groups::Secp256k1DecryptionKeySharePublicParameters,
            DecryptionKeyShare = SecretKeyShareSizedInteger,
            SecretKey = group::Value<secp256k1::Scalar>,
        > + MockablePresignProtocol,
        <<P as Protocol>::SignDecentralizedParty as mpc::Party>::Message: Send + Sync,
    {
        let access_structure =
            WeightedThresholdAccessStructure::new(threshold, party_to_weight.clone()).unwrap();

        let (protocol_public_parameters, decryption_key) = setup_class_groups_secp256k1();

        let secret_key_bits = protocol_public_parameters
            .encryption_scheme_public_parameters
            .randomness_space_public_parameters()
            .sample_bits;

        let base = protocol_public_parameters
            .encryption_scheme_public_parameters
            .setup_parameters
            .h;

        let (decryption_key_share_public_parameters, decryption_key_shares) =
            ::class_groups::test_helpers::deal_trusted_shares::<
                { U256::LIMBS },
                { crate::secp256k1::class_groups::FUNDAMENTAL_DISCRIMINANT_LIMBS },
                { crate::secp256k1::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS },
                secp256k1::GroupElement,
            >(
                threshold,
                access_structure.number_of_virtual_parties(),
                protocol_public_parameters
                    .encryption_scheme_public_parameters
                    .clone(),
                decryption_key.decryption_key,
                base,
                secret_key_bits,
            );

        let decryption_key_shares: Vec<_> = decryption_key_shares
            .into_iter()
            .map(|(virtual_party_id, decryption_key_share)| {
                let decryption_key_share = if malicious_parties.contains(
                    &access_structure
                        .to_tangible_party_id(virtual_party_id)
                        .unwrap(),
                ) {
                    let wrong_share = Uint::random(&mut OsCsRng);
                    let wrong_share = wrong_share
                        & (Uint::ONE
                            << secret_key_share_size_upper_bound(
                                u32::from(access_structure.number_of_virtual_parties()),
                                u32::from(access_structure.threshold),
                                secret_key_bits,
                            ));

                    Int::new_from_abs_sign(
                        wrong_share,
                        ConstChoice::from(Choice::from(u8::from(virtual_party_id % 2 == 0))),
                    )
                    .unwrap()
                } else {
                    decryption_key_share
                };

                (virtual_party_id, decryption_key_share)
            })
            .collect();

        let access_structure =
            WeightedThresholdAccessStructure::new(threshold, party_to_weight).unwrap();

        let party_to_virtual_parties = access_structure.party_to_virtual_parties();
        let tangible_party_id_to_virtual_party_id_to_decryption_key_share: HashMap<
            _,
            HashMap<_, _>,
        > = party_to_virtual_parties
            .keys()
            .map(|&tangible_party_id| {
                let virtual_parties = party_to_virtual_parties
                    .get(&tangible_party_id)
                    .cloned()
                    .unwrap();
                (
                    tangible_party_id,
                    decryption_key_shares
                        .clone()
                        .into_iter()
                        .filter(|(party_id, _)| virtual_parties.contains(party_id))
                        .collect(),
                )
            })
            .collect();

        let (
            centralized_party_dkg_output,
            centralized_party_secret_key_share,
            decentralized_party_dkg_output,
        ) = mock_targeted_dkg_output::<
            { secp256k1::SCALAR_LIMBS },
            { secp256k1::SCALAR_LIMBS },
            secp256k1::GroupElement,
            Secp256k1EncryptionKey,
        >(&protocol_public_parameters);

        let presign_session_id = CommitmentSizedNumber::random(&mut OsCsRng);

        let presign = P::mock_presign(
            presign_session_id,
            decentralized_party_dkg_output.clone(),
            &protocol_public_parameters,
        );

        signs_internal_generic::<
            { secp256k1::SCALAR_LIMBS },
            { secp256k1::SCALAR_LIMBS },
            secp256k1::GroupElement,
            Secp256k1EncryptionKey,
            P,
        >(
            presign_session_id,
            access_structure,
            hash_type,
            centralized_party_secret_key_share,
            centralized_party_dkg_output,
            decentralized_party_dkg_output,
            presign,
            decryption_key_share_public_parameters,
            tangible_party_id_to_virtual_party_id_to_decryption_key_share,
            message,
            verify_signature,
            protocol_public_parameters,
            description.to_string(),
            malicious_parties,
            bench,
            expected_case,
        );
    }

    pub(crate) fn dkg_presign_signs_internal<
        const SCALAR_LIMBS: usize,
        const PLAINTEXT_SPACE_SCALAR_LIMBS: usize,
        GroupElement: PrimeGroupElement<SCALAR_LIMBS>,
        EncryptionKey: AdditivelyHomomorphicEncryptionKey<PLAINTEXT_SPACE_SCALAR_LIMBS>,
        P,
    >(
        dkg_session_id: CommitmentSizedNumber,
        access_structure: WeightedThresholdAccessStructure,
        hash_type: HashScheme,
        decryption_key_share_public_parameters: P::DecryptionKeySharePublicParameters,
        tangible_party_id_to_virtual_party_id_to_decryption_key_share: HashMap<
            PartyID,
            HashMap<PartyID, P::DecryptionKeyShare>,
        >,
        message: &[u8],
        verify_signature: fn(
            public_key: GroupElement,
            signature: P::Signature,
            message: &[u8],
            hash_type: HashScheme,
        ) -> crate::Result<()>,
        protocol_public_parameters: P::ProtocolPublicParameters,
        is_trusted_dealer: bool,
        description: String,
    ) -> (
        P::CentralizedPartyDKGOutput,
        P::CentralizedPartySecretKeyShare,
        P::DecentralizedPartyDKGOutput,
    )
    where
        GroupElement::Scalar: From<Uint<PLAINTEXT_SPACE_SCALAR_LIMBS>>,
        P: Protocol<
            CentralizedPartyDKGOutput = crate::dkg::centralized_party::VersionedOutput<
                SCALAR_LIMBS,
                group::Value<GroupElement>,
            >,
            CentralizedPartySecretKeyShare = SecretKeyShare<group::Value<GroupElement::Scalar>>,
            DecentralizedPartyDKGOutput = crate::dkg::decentralized_party::VersionedOutput<
                SCALAR_LIMBS,
                GroupElement::Value,
                group::Value<EncryptionKey::CiphertextSpaceGroupElement>,
            >,
            DecentralizedPartyTargetedDKGOutput = crate::dkg::decentralized_party::Output<
                GroupElement::Value,
                group::Value<EncryptionKey::CiphertextSpaceGroupElement>,
            >,
            PublicKeyShareAndProof = PublicKeyShareAndProof<
                group::Value<GroupElement>,
                KnowledgeOfDiscreteLogUCProof<SCALAR_LIMBS, GroupElement>,
            >,
            SecretKey = group::Value<GroupElement::Scalar>,
        >,
        P::ProtocolPublicParameters: AsRef<
            ProtocolPublicParameters<
                group::PublicParameters<GroupElement::Scalar>,
                GroupElement::PublicParameters,
                GroupElement::Value,
                homomorphic_encryption::CiphertextSpaceValue<
                    PLAINTEXT_SPACE_SCALAR_LIMBS,
                    EncryptionKey,
                >,
                EncryptionKey::PublicParameters,
            >,
        >,
        Uint<SCALAR_LIMBS>: Encoding,
    {
        let (
            centralized_party_dkg_output,
            centralized_party_secret_key_share,
            decentralized_party_dkg_output,
        ) = if is_trusted_dealer {
            deals_trusted_shares_internal::<
                SCALAR_LIMBS,
                PLAINTEXT_SPACE_SCALAR_LIMBS,
                GroupElement,
                EncryptionKey,
                P,
            >(
                dkg_session_id,
                access_structure.clone(),
                protocol_public_parameters.clone(),
            )
        } else {
            generates_distributed_key_internal::<
                SCALAR_LIMBS,
                PLAINTEXT_SPACE_SCALAR_LIMBS,
                GroupElement,
                EncryptionKey,
                P,
            >(
                dkg_session_id,
                access_structure.clone(),
                protocol_public_parameters.clone(),
                description.clone(),
            )
        };

        presign_signs_internal::<
            SCALAR_LIMBS,
            PLAINTEXT_SPACE_SCALAR_LIMBS,
            GroupElement,
            EncryptionKey,
            P,
        >(
            access_structure,
            hash_type,
            centralized_party_dkg_output.clone(),
            centralized_party_secret_key_share,
            decentralized_party_dkg_output.clone(),
            decryption_key_share_public_parameters,
            tangible_party_id_to_virtual_party_id_to_decryption_key_share,
            message,
            verify_signature,
            protocol_public_parameters,
            description,
        );

        (
            centralized_party_dkg_output,
            centralized_party_secret_key_share,
            decentralized_party_dkg_output,
        )
    }

    pub(crate) fn presign_signs_internal<
        const SCALAR_LIMBS: usize,
        const PLAINTEXT_SPACE_SCALAR_LIMBS: usize,
        GroupElement: PrimeGroupElement<SCALAR_LIMBS>,
        EncryptionKey: AdditivelyHomomorphicEncryptionKey<PLAINTEXT_SPACE_SCALAR_LIMBS>,
        P,
    >(
        access_structure: WeightedThresholdAccessStructure,
        hash_type: HashScheme,
        centralized_party_dkg_output: P::CentralizedPartyDKGOutput,
        centralized_party_secret_key_share: P::CentralizedPartySecretKeyShare,
        decentralized_party_dkg_output: P::DecentralizedPartyDKGOutput,
        decryption_key_share_public_parameters: P::DecryptionKeySharePublicParameters,
        tangible_party_id_to_virtual_party_id_to_decryption_key_share: HashMap<
            PartyID,
            HashMap<PartyID, P::DecryptionKeyShare>,
        >,
        message: &[u8],
        verify_signature: fn(
            public_key: GroupElement,
            signature: P::Signature,
            message: &[u8],
            hash_type: HashScheme,
        ) -> crate::Result<()>,
        protocol_public_parameters: P::ProtocolPublicParameters,
        description: String,
    ) where
        GroupElement::Scalar: From<Uint<PLAINTEXT_SPACE_SCALAR_LIMBS>>,
        P: Protocol<
            CentralizedPartyDKGOutput = crate::dkg::centralized_party::VersionedOutput<
                SCALAR_LIMBS,
                group::Value<GroupElement>,
            >,
            CentralizedPartySecretKeyShare = SecretKeyShare<group::Value<GroupElement::Scalar>>,
            DecentralizedPartyDKGOutput = crate::dkg::decentralized_party::VersionedOutput<
                SCALAR_LIMBS,
                GroupElement::Value,
                group::Value<EncryptionKey::CiphertextSpaceGroupElement>,
            >,
            DecentralizedPartyTargetedDKGOutput = crate::dkg::decentralized_party::Output<
                GroupElement::Value,
                group::Value<EncryptionKey::CiphertextSpaceGroupElement>,
            >,
            PublicKeyShareAndProof = PublicKeyShareAndProof<
                group::Value<GroupElement>,
                KnowledgeOfDiscreteLogUCProof<SCALAR_LIMBS, GroupElement>,
            >,
            SecretKey = group::Value<GroupElement::Scalar>,
        >,
        P::ProtocolPublicParameters: AsRef<
            ProtocolPublicParameters<
                group::PublicParameters<GroupElement::Scalar>,
                GroupElement::PublicParameters,
                GroupElement::Value,
                homomorphic_encryption::CiphertextSpaceValue<
                    PLAINTEXT_SPACE_SCALAR_LIMBS,
                    EncryptionKey,
                >,
                EncryptionKey::PublicParameters,
            >,
        >,
        Uint<SCALAR_LIMBS>: Encoding,
    {
        let parties: Vec<PartyID> = access_structure
            .party_to_virtual_parties()
            .keys()
            .copied()
            .collect();

        let dkg_output = match decentralized_party_dkg_output.clone() {
            crate::dkg::decentralized_party::VersionedOutput::TargetedPublicDKGOutput(
                dkg_output,
            ) => Some(dkg_output),
            crate::dkg::decentralized_party::VersionedOutput::UniversalPublicDKGOutput {
                ..
            } => None,
        };

        let encryption_of_mask_and_masked_key_share_round_public_inputs = parties
            .into_iter()
            .map(|party_id| {
                (
                    party_id,
                    (protocol_public_parameters.clone(), dkg_output.clone()).into(),
                )
            })
            .collect();

        let presign_session_id = CommitmentSizedNumber::random(&mut OsCsRng);
        let presign = generates_presignatures_internal::<
            SCALAR_LIMBS,
            PLAINTEXT_SPACE_SCALAR_LIMBS,
            GroupElement,
            EncryptionKey,
            P,
        >(
            presign_session_id,
            access_structure.clone(),
            encryption_of_mask_and_masked_key_share_round_public_inputs,
            description.clone(),
        );

        signs_internal_generic::<
            SCALAR_LIMBS,
            PLAINTEXT_SPACE_SCALAR_LIMBS,
            GroupElement,
            EncryptionKey,
            P,
        >(
            presign_session_id,
            access_structure,
            hash_type,
            centralized_party_secret_key_share,
            centralized_party_dkg_output,
            decentralized_party_dkg_output,
            presign,
            decryption_key_share_public_parameters,
            tangible_party_id_to_virtual_party_id_to_decryption_key_share,
            message,
            verify_signature,
            protocol_public_parameters,
            description.clone(),
            HashSet::new(),
            false,
            true,
        );
    }

    pub(crate) fn verify_secp256r1_ecdsa_signature(
        public_key: secp256r1::GroupElement,
        signature: ECDSASecp256r1Signature,
        message: &[u8],
        hash_type: HashScheme,
    ) -> crate::Result<()> {
        <secp256r1::GroupElement as crate::ecdsa::VerifyingKey<{ secp256r1::SCALAR_LIMBS }>>::verify(
            &public_key,
            message,
            hash_type,
            &signature,
        )
    }

    pub(crate) fn verify_secp256k1_ecdsa_signature(
        public_key: secp256k1::GroupElement,
        signature: ECDSASecp256k1Signature,
        message: &[u8],
        hash_type: HashScheme,
    ) -> crate::Result<()> {
        <secp256k1::GroupElement as crate::ecdsa::VerifyingKey<{ secp256k1::SCALAR_LIMBS }>>::verify(
            &public_key,
            message,
            hash_type,
            &signature,
        )
    }

    pub(crate) fn verify_taproot_signature(
        public_key: secp256k1::GroupElement,
        signature: TaprootSignature,
        message: &[u8],
        hash_type: HashScheme,
    ) -> crate::Result<()> {
        <secp256k1::GroupElement as schnorr::VerifyingKey<{ secp256k1::SCALAR_LIMBS }>>::verify(
            &public_key,
            message,
            hash_type,
            &signature,
        )
    }

    pub(crate) fn verify_schnorrkel_signature(
        public_key: ristretto::GroupElement,
        signature: SchnorrkelSubstrateSignature,
        message: &[u8],
        hash_type: HashScheme,
    ) -> crate::Result<()> {
        <ristretto::GroupElement as schnorr::VerifyingKey<{ ristretto::SCALAR_LIMBS }>>::verify(
            &public_key,
            message,
            hash_type,
            &signature,
        )
    }

    pub(crate) fn verify_eddsa_signature(
        public_key: curve25519::GroupElement,
        signature: EdDSASignature,
        message: &[u8],
        hash_type: HashScheme,
    ) -> crate::Result<()> {
        <curve25519::GroupElement as schnorr::VerifyingKey<{ curve25519::SCALAR_LIMBS }>>::verify(
            &public_key,
            message,
            hash_type,
            &signature,
        )
    }

    pub trait MockablePresignProtocol: Protocol {
        fn mock_presign(
            session_id: CommitmentSizedNumber,
            dkg_output: Self::DecentralizedPartyDKGOutput,
            protocol_public_parameters: &Self::ProtocolPublicParameters,
        ) -> Self::Presign;
    }

    impl MockablePresignProtocol for ECDSAProtocol {
        fn mock_presign(
            session_id: CommitmentSizedNumber,
            dkg_output: Self::DecentralizedPartyDKGOutput,
            protocol_public_parameters: &Self::ProtocolPublicParameters,
        ) -> Self::Presign {
            mock_ecdsa_presign::<
                { secp256k1::SCALAR_LIMBS },
                { secp256k1::SCALAR_LIMBS },
                secp256k1::GroupElement,
                ::class_groups::EncryptionKey<
                    { secp256k1::SCALAR_LIMBS },
                    { crate::secp256k1::class_groups::FUNDAMENTAL_DISCRIMINANT_LIMBS },
                    { crate::secp256k1::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS },
                    secp256k1::GroupElement,
                >,
            >(session_id, dkg_output, protocol_public_parameters)
        }
    }

    impl MockablePresignProtocol for TaprootProtocol {
        fn mock_presign(
            session_id: CommitmentSizedNumber,
            _dkg_output: Self::DecentralizedPartyDKGOutput,
            protocol_public_parameters: &Self::ProtocolPublicParameters,
        ) -> Self::Presign {
            mock_schnorr_presign::<
                { secp256k1::SCALAR_LIMBS },
                { secp256k1::SCALAR_LIMBS },
                secp256k1::GroupElement,
                ::class_groups::EncryptionKey<
                    { secp256k1::SCALAR_LIMBS },
                    { crate::secp256k1::class_groups::FUNDAMENTAL_DISCRIMINANT_LIMBS },
                    { crate::secp256k1::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS },
                    secp256k1::GroupElement,
                >,
            >(session_id, protocol_public_parameters)
        }
    }

    impl MockablePresignProtocol for crate::curve25519::class_groups::EdDSAProtocol {
        fn mock_presign(
            session_id: CommitmentSizedNumber,
            _dkg_output: Self::DecentralizedPartyDKGOutput,
            protocol_public_parameters: &Self::ProtocolPublicParameters,
        ) -> Self::Presign {
            mock_schnorr_presign::<
                { curve25519::SCALAR_LIMBS },
                { curve25519::SCALAR_LIMBS },
                curve25519::GroupElement,
                ::class_groups::EncryptionKey<
                    { curve25519::SCALAR_LIMBS },
                    { crate::curve25519::class_groups::FUNDAMENTAL_DISCRIMINANT_LIMBS },
                    { crate::curve25519::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS },
                    curve25519::GroupElement,
                >,
            >(session_id, protocol_public_parameters)
        }
    }

    impl MockablePresignProtocol for crate::ristretto::class_groups::SchnorrkelSubstrateProtocol {
        fn mock_presign(
            session_id: CommitmentSizedNumber,
            _dkg_output: Self::DecentralizedPartyDKGOutput,
            protocol_public_parameters: &Self::ProtocolPublicParameters,
        ) -> Self::Presign {
            mock_schnorr_presign::<
                { ristretto::SCALAR_LIMBS },
                { ristretto::SCALAR_LIMBS },
                ristretto::GroupElement,
                ::class_groups::EncryptionKey<
                    { ristretto::SCALAR_LIMBS },
                    { crate::ristretto::class_groups::FUNDAMENTAL_DISCRIMINANT_LIMBS },
                    { crate::ristretto::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS },
                    ristretto::GroupElement,
                >,
            >(session_id, protocol_public_parameters)
        }
    }

    impl MockablePresignProtocol for crate::secp256r1::class_groups::ECDSAProtocol {
        fn mock_presign(
            session_id: CommitmentSizedNumber,
            dkg_output: Self::DecentralizedPartyDKGOutput,
            protocol_public_parameters: &Self::ProtocolPublicParameters,
        ) -> Self::Presign {
            mock_ecdsa_presign::<
                { secp256r1::SCALAR_LIMBS },
                { secp256r1::SCALAR_LIMBS },
                secp256r1::GroupElement,
                ::class_groups::EncryptionKey<
                    { secp256r1::SCALAR_LIMBS },
                    { crate::secp256r1::class_groups::FUNDAMENTAL_DISCRIMINANT_LIMBS },
                    { crate::secp256r1::class_groups::NON_FUNDAMENTAL_DISCRIMINANT_LIMBS },
                    secp256r1::GroupElement,
                >,
            >(session_id, dkg_output, protocol_public_parameters)
        }
    }
}

#[cfg(all(test, feature = "benchmarking"))]
mod benches {
    use std::collections::HashSet;

    use crate::secp256k1::class_groups::ECDSAProtocol;
    use crate::sign::tests::{verify_secp256k1_ecdsa_signature, MESSAGE};
    use group::{HashScheme, OsCsRng};
    use mpc::WeightedThresholdAccessStructure;

    #[test]
    #[ignore]
    #[allow(clippy::single_element_loop)]
    fn benchmark() {
        println!(
            "\nProtocol, Number of Parties, Threshold, Batch Size, Centralized Party Total Time (ms), Decentralized Party Total Time (ms), Decentralized Party Decryption Share Time (ms), Decentralized Party Threshold Decryption Time (ms)",
        );

        for (threshold, number_of_tangible_parties, total_weight) in [(67, 100, 100)] {
            let access_structure = WeightedThresholdAccessStructure::uniform(
                threshold,
                number_of_tangible_parties,
                total_weight,
                &mut OsCsRng,
            )
            .unwrap();

            super::tests::signs_async_class_groups_secp256k1_internal::<ECDSAProtocol>(
                access_structure.threshold,
                access_structure.party_to_weight.clone(),
                HashScheme::SHA256,
                HashSet::new(),
                true,
                true,
                MESSAGE.as_bytes(),
                verify_secp256k1_ecdsa_signature,
                "Class Groups Asynchronous ECDSA secp256k1",
            );

            super::tests::signs_async_class_groups_secp256k1_internal::<ECDSAProtocol>(
                access_structure.threshold,
                access_structure.party_to_weight,
                HashScheme::Keccak256,
                HashSet::new(),
                true,
                false,
                MESSAGE.as_bytes(),
                verify_secp256k1_ecdsa_signature,
                "Class Groups Asynchronous ECDSA secp256k1",
            );
        }
    }
}
